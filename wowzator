#!/usr/bin/python3

import httpx
from httpx._exceptions import NetworkError
import xmltodict
import json



class WztrApplication():
    header_singular="Application"
    header_plural="Applications"

    def __init__(self, name, href, appType, dvrEnabled=False, drmEnabled=False, transcoderEnabled=False, streamtargetsEnabled=False):
        self.name = name
        self.href = href
        self.appType = appType

        if dvrEnabled == "true":
            self.dvrEnabled = True
        else:
            self.dvrEnabled = False
        if drmEnabled == "true":
            self.drmEnabled = True
        else:
            self.drmEnabled = False
        if transcoderEnabled == "true":
            self.transcoderEnabled = True
        else:
            self.transcoderEnabled = False
        if streamtargetsEnabled == "true":
            self.streamtargetsEnabled = True
        else:
            self.streamtargetsEnabled = False
    
        self.vhost=None
        self.__configuration = None
        self.__configurationAdv = None # this is how app Properties are called in wowza APIs
        
    def __str__(self):
        return "/%s/%s/%s" % (self.vhost.machine.name, self.vhost.name, self.name)
    def __repr__(self):
        return "WztrApplication: %s" % self.name

    @staticmethod
    def list_view_header():
        return "%-8s %-28s %1s%1s%1s%1s" % ("App Type", "Stream Type", "(DVR)", "(DRM)", "(TRC)", "(STG)")
    def list_view(self):
        stream_type="n/a"
        config_dict = self.configuration()
        if config_dict is not None and 'StreamConfig' in config_dict.keys() and 'StreamType' in config_dict['StreamConfig'].keys():
            stream_type = config_dict['StreamConfig']['StreamType']
        
        return "%-8s %-28s %1s%1s%1s%1s  /%s/%s/%s" % (self.appType, stream_type,
            "X" if self.dvrEnabled else "-", "X" if self.drmEnabled else "-",
            "X" if self.transcoderEnabled else "-", "X" if self.streamtargetsEnabled else "-",
            self.vhost.machine.name, self.vhost.name, self.name)
    def detail_view(self):
        stream_type="n/a"
        config_dict = self.configuration()
        if config_dict is not None and 'StreamConfig' in config_dict.keys() and 'StreamType' in config_dict['StreamConfig'].keys():
            stream_type = config_dict['StreamConfig']['StreamType']
        return {
            "App/Stream type": self.appType + " / " + stream_type,
            "Server": "/%s/%s/%s" % (self.vhost.machine.name, self.vhost.name, self.name),
            "DVR": "** ON" if self.dvrEnabled else "OFF",
            "DRM": "** ON" if self.drmEnabled else "OFF",
            "Transcoder": "** ON" if self.transcoderEnabled else "OFF",
            "Targets": "** ON" if self.streamtargetsEnabled else "OFF"
        }


    def configuration(self):
        # lazy-fetch application config
        if self.__configuration is None:
            self.__configuration={}

            result = self.vhost.machine.fetchDict(self.href)
            if result["status"] == "OK":
                if 'Application' in result["data"].keys():
                    entry = result["data"]['Application']
                
                    if 'Version' in entry.keys():
                        del entry['Version']
                
                
                    if not self.dvrEnabled and 'DVRConfig' in entry.keys():
                        del entry['DVRConfig']
                    if not self.drmEnabled and 'DRMConfig' in entry.keys():
                        del entry['DRMConfig']
                    if not self.transcoderEnabled and 'TranscoderConfig' in entry.keys():
                        del entry['TranscoderConfig']
                
                    self.__configuration = WztrApplication.__clean_config_dict(entry)

        return self.__configuration
    
    @staticmethod
    # recursively remove irrelevant items from configuration dictionary
    def __clean_config_dict(config_dict):
        if '@serverName' in config_dict.keys():
            del config_dict['@serverName']
        
        for key in config_dict.keys():
            if isinstance(config_dict[key], dict):
                cleanitem = WztrApplication.__clean_config_dict(config_dict[key])
                config_dict[key] = cleanitem
        return config_dict
        
    # in wowza APIs, application Properties are referred to as application/advanced
    def configurationAdvanced(self):
        # lazy-fetch application advanced config
        if self.__configurationAdv is None:
            self.__configurationAdv={}
            
            result = self.vhost.machine.fetchDict(self.href + "/adv")
            if result["status"] == "OK":
                if 'ApplicationAdv' in result["data"].keys():
                    if 'AdvancedSettings' in result["data"]['ApplicationAdv'].keys():
                        advSettings = result["data"]['ApplicationAdv']['AdvancedSettings']
                        if 'AdvancedSetting' in advSettings.keys():
                            # show only active properties
                            properties=[]
                            for prop in advSettings['AdvancedSetting']:
                                if prop['@enabled'] == 'true':
                                    shortprop = {
                                        'Name': prop['Name'],
                                        'Type': prop['Type'],
                                        'Value': prop['Value'],
                                        'SectionName': "",
                                        'Section': ""
                                    
                                    }
                                    if 'Section' in prop.keys():
                                        shortprop['Section'] = prop['Section']
                                    if 'SectionName' in prop.keys():
                                        shortprop['SectionName'] = prop['SectionName']
                            
                                    properties.append(shortprop)
                            
                            self.__configurationAdv=properties

        return self.__configurationAdv
        
        
class WztrVhost():
    header_singular="VHost"
    header_plural="VHosts"

    def __init__(self, name, href, connectingIPAddress, connectingPort, connectingSSLEnable=False):
        self.name = name
        self.href = href
        self.connectingPort = connectingPort
        self.connectingIPAddress = connectingIPAddress
        if connectingSSLEnable == "true":
            self.connectingSSLEnable = True
        else:
            self.connectingSSLEnable = False
    
        self.__applications = None
        self.machine=None
    
    def __str__(self):
        return "/%s/%s" % (self.machine.name, self.name)
    def __repr__(self):
        return "WztrVhost: %s" % self.name

    @staticmethod
    def list_view_header():
        return "VHost name"
    def list_view(self):
        return str(self)
    def detail_view(self):
        return {
            "Machine": str(self.machine),
            "Addr/Port": "%s/%s" % (self.connectingIPAddress, self.connectingPort),
            "SSL": "YES" if self.connectingSSLEnable else "NO",
        }
    
    
    def applications(self):
        # lazy-fetch applications
        if self.__applications is None:
            self.__applications={}
            result = self.machine.fetchDict("/v2/servers/_defaultServer_/vhosts/%s/applications" % self.name)

            if result["status"] == "OK":
                if 'Applications' in result["data"].keys():
                    entry = result["data"]['Applications']
                    if 'Application' in entry.keys():
                        items = entry['Application']
                        for item in items:
                            newapp = WztrApplication(item['@id'], item['@href'], item['AppType'], item['DVREnabled'], item['DRMEnabled'], item['TranscoderEnabled'], item['StreamTargetsEnabled'])
                            newapp.vhost = self
                    
                            self.__applications[newapp.name] = newapp

        return self.__applications

# class used to create a temporary list of licenses and associated servers
# using a class in order to avail of the code to render lists
class WztrLicense():
    header_singular="License"
    header_plural="Licenses"
    
    def __init__(self, key):
        self.key=key
        self.servers=[]

    def __str__(self):
        return self.key
    def __repr__(self):
        return "WztrLicense: %s" % self.key
    
    @staticmethod
    def list_view_header():
        return " %-36s  servers" % ("License key")
    def list_view(self):
        return " %-36s [%s]" % (self.key, ", ".join(self.servers))
    def detail_view(self):
        return {
            "License key": self.key,
            "Servers": self.serers(),
        }
    
    def add_server(self, machine):
        self.servers.append(machine.name)


    
class WztrMachine():
    header_singular="Machine"
    header_plural="Machines"
    
    def __init__(self, name, address, user, pw, port=None):
        self.name=name
        self.address=address
        self.user=user
        self.pw=pw
        self.use_https=False
        self.__vhosts = None
        self.__version = None
        self.__licenses = None
        
        if port is not None:
            self.port=port
        else:
            self.port="8087"

    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrMachine: %s" % self.name

    @staticmethod
    def list_view_header():
        return " %-10s %-17s  %s" % ("Name", " address", "Wowza version")
    def list_view(self):
        return " %-10s %-17s [%s]" % (self.name, "(" + self.address + ")", self.version())
    def detail_view(self):
        return {
            "Address": self.address,
            "Version": self.version(),
            "HTTPS": "YES" if self.use_https else "NO",
            "Credentials": {
                "user": self.user,
                "pw": "*******"
            },
            "Licenses": self.licenses()
        }
        
    def fetch(self, url):
        data=""
        status="OK"
        try:
            base_url="http://"
            if self.use_https:
                base_url="https://"
            
            base_url += self.address
            url = "%s:%s%s" % (base_url, self.port, url) 
            
            response = httpx.get(
                url,
                auth=httpx.DigestAuth(
                    self.user, self.pw
                ),
                timeout=httpx.Timeout(timeout=3)
            )
            
            data = response.text

        except NetworkError:
            data='timeout getting %s on machine %s' % (url, self)
            status="KO"
        except Exception as e:
            data='error getting %s on machine %s' % (url, self)
            print(e)
            status="KO"
        
        return {"data": data, "status": status}
        
    def fetchDict(self, url):
        response = self.fetch(url)
        
        if response["status"] == "OK":
            try:
                response["data"] = xmltodict.parse(
                    response["data"],
                    dict_constructor=dict,
                    xml_attribs=True,
                    force_list=('VHosts')
                )
            except:
                response["status"] = "KO"
                response["data"] = "invalid XML reply"
                
        return response
    
    
    def reset_cache(self):
        self.__vhosts = None
        self.__version = None
    
    def vhosts(self):
        # lazy-fetch vhosts
        if self.__vhosts is None:
            self.__vhosts={}
            result = self.fetchDict("/v2/servers/_defaultServer_/vhosts")
            if result["status"] == "OK":
                if 'VHosts' in result["data"].keys():
                    for vhost_entry in result["data"]['VHosts']:
                        vhost = vhost_entry['Vhost']
                        newvh = WztrVhost(vhost['@id'], vhost['@href'], vhost['@connectingIPAddress'], vhost['@connectingPort'], vhost['@connectingSSLEnable'])
                        newvh.machine = self
                    
                        self.__vhosts[newvh.name] = newvh

        return self.__vhosts

    def version(self):
        # lazy-fetch version
        if self.__version is None:
            self.__version = "*** No connection ***"
            result = self.fetch("")
            if result["status"] == "OK":
                self.__version = (result["data"])
        
        return self.__version



    def licenses(self):
        # lazy-fetch machine licenses
        if self.__licenses is None:
            self.__licenses = {}
            result = self.fetchDict("/v2/servers/_defaultServer_/licenses")
            if result["status"] == "OK":
                if 'ServerLicenses' in result["data"].keys():
                    entry = result["data"]['ServerLicenses']
                
                    if 'Licenses' in entry.keys():
                        entry = entry['Licenses']
                        if 'string' in entry.keys():
                            index=0
                            if isinstance(entry['string'], list):
                                for lic in entry['string']:
                                    self.__licenses[index] = lic
                                    index += 1
                            else:
                                self.__licenses[index] = entry['string']

        return self.__licenses





from cmd2 import Cmd
import json, sys

_CONFIGFILE="config.json"





class WztrPrompt(Cmd):
    prompt = 'wowzator> '
    intro = "\nWowzator: a simple Wowza Configuration Manager by Top-IX\nType ? to list commands, TAB to autocomplete\n"
    
    
    # Syntax tree for the list commeand
    syntaxtree_ls = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": [
                        {
                            "keyword": "$APPLICATION",
                            "keyword_type": "object",
                            "syntaxtree": [
                                {
                                    "keyword": "configuration",
                                    "keyword_type": "predicate",
                                    "syntaxtree": [
                                        {
                                            "keyword": "properties",
                                            "keyword_type": "predicate",
                                            "syntaxtree": []
                                        }
                                    ]
                                },
                                {
                                    "keyword": "details",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                }
                            ]
                        },
                        {
                            "keyword": "details",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        },
                        {
                            "keyword": "transcoders",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        }
                    ]
                },
                {
                    "keyword": "details",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                }
            ]
        },
        {
            "keyword": "$ALL_MACHINES",
            "keyword_type": "multi_object",
            "syntaxtree": [
                {
                    "keyword": "applications",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                },
                {
                    "keyword": "licenses",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                }
            ]
        }
    ]


    # Syntax tree for the diff commeand (first argument)
    syntaxtree_diff_1 = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": [
                        {
                            "keyword": "$APPLICATION",
                            "keyword_type": "object",
                            "syntaxtree": [
                                {
                                    "keyword": "config",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                }
                            ]
                        },
                        {
                            "keyword": "transcoders",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        }
                    ]
                } 
            ]
        },
    ]
    # Syntax tree for the diff commeand (second argument)
    syntaxtree_diff_2 = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": []
        },
    ]
    
    
    def __init__(self):
        print("initializing...")
        Cmd.__init__(self)
        
        self.machines = {}
        self.relationsLicenseServer = []
        
        try:
            with open(_CONFIGFILE) as json_file:
                machines_config = json.load(json_file)
        
                for machine_config in machines_config:
                    machine=WztrMachine(name=machine_config["name"], address=machine_config["address"], user=machine_config["user"], pw=machine_config["pw"])
                    self.machines[machine.name]=machine
            

        except Exception as e:
            print(e)
            print("Cannot open %s" % _CONFIGFILE)
            sys.exit(-1)
    
    def do_exit(self, inp):
        print('Bye')
        return True
    
    do_EOF=do_exit
    do_q=do_exit

    # return an array of objects or a single instance depending on what the path points to
    def __get_obj_by_path(self, syntax_tree, path):
        self.command_object = None
        self.command_objects = None
        self.command_predicate = None
        self.command_error = None
        
        completion = []
        
        
        path_arr = path.split("/")
        
        removed_trailing_slash = False
        removed_leading_slash = False
        # set to True by default to deal with empty path
        # if path is provided it will be immediately set to False when path is parsed
        keyword_matched = True
        
        # remove last and first elements of path if empty
        if len(path_arr) > 0 and path_arr[-1] == "":
            path_arr.pop()
            removed_trailing_slash = True
        if len(path_arr) > 0 and path_arr[0] == "":
            path_arr.pop(0)
            removed_leading_slash = True
        
        expanded_syntax_tree = self.__expand_keywords(syntax_tree)
        cur_path_pos = 0
        for cur_path_el in path_arr:
            
            keyword_matched = False
            for syntax_el in expanded_syntax_tree:
                if cur_path_el == syntax_el["keyword"]:

                    if syntax_el["keyword_type"] == "object":
                        self.command_object = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "multi_object":
                        self.command_objects = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "predicate":
                        self.command_predicate = syntax_el["keyword"]

                    # move down syntax tree
                    expanded_syntax_tree = self.__expand_keywords(syntax_el["syntaxtree"])
                    keyword_matched = True
            
            if not keyword_matched:
                self.command_error = "%s: keyword not recognized" % cur_path_el
                cur_path = "/".join(path_arr[:cur_path_pos])
                if cur_path != "":
                    cur_path += "/"
                if removed_leading_slash:
                    cur_path = "/" + cur_path
            
                for syntax_el in expanded_syntax_tree:
                    completion_item = cur_path + syntax_el["keyword"]
                    completion.append( completion_item )
                    # if len(syntax_el["syntaxtree"]) > 0:
                    #    completion.append( cur_path + syntax_el["keyword"] +"/" )

                break
            
                
            cur_path_pos += 1
                
        if keyword_matched:
            cur_path = "/".join(path_arr[:cur_path_pos])
            if cur_path != "":
                cur_path += "/"
            if removed_leading_slash:
                cur_path = "/" + cur_path
        
            for syntax_el in expanded_syntax_tree:
                completion_item = cur_path + syntax_el["keyword"]
                completion.append( completion_item )
                # if len(syntax_el["syntaxtree"]) > 0:
                #    completion.append( cur_path + syntax_el["keyword"] +"/" )
            
        
        return {
            "object": self.command_object,
            "objects": self.command_objects,
            "predicate": self.command_predicate,
            "error": self.command_error,
            "completion": completion
        }

    
    # expand macro keywords in first level of syntax tree
    def __expand_keywords(self, syntax_tree):
        expanded_syntax_tree = []
        for syntax_el in syntax_tree:
            kw = syntax_el["keyword"]
            if kw[0] == "$":
                expanded_dict = self.__expand_keyword_macro(kw)
                for expanded_kw in expanded_dict.keys():
                    exp_syntax_el = {
                        "keyword": expanded_kw,
                        "keyword_type": syntax_el["keyword_type"],
                        "syntaxtree": syntax_el["syntaxtree"],
                        "data": expanded_dict[expanded_kw]
                    }
                    expanded_syntax_tree.append(exp_syntax_el)
            else:
                expanded_syntax_tree.append(syntax_el)
        
        return expanded_syntax_tree
    
    
    
    
    # expand individual macro
    def __expand_keyword_macro(self, keyword):
        expanded_dict = {}
        if keyword == "$MACHINE":
            expanded_dict = self.machines
            #for machine_name in self.machines.keys():
            #    expanded_dict[machine_name]=self.machines[machine_name]
        elif keyword == "$ALL_MACHINES":
            expanded_dict["all"]=self.machines.values()
        elif keyword == "$VHOST":
            expanded_dict = self.command_object.vhosts()
        elif keyword == "$APPLICATION":
            expanded_dict = self.command_object.applications()
        
        return expanded_dict


    def do_ls(self, inp):
        print()
        
        self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, inp)
        
        if self.command_error is None:
            if self.command_object is None:
                if self.command_objects is None:
                    self.__ls_objects(self.machines.values(), self.command_predicate)
                else:
                    self.__ls_objects(self.command_objects, self.command_predicate)
            else:
                self.__ls_object(self.command_object, self.command_predicate)
        else:
            print("** Error: %s" % self.command_error)

    def __ls_objects(self, object_list, predicate=None):
        object_list = list(object_list)
        if len(object_list) > 0:
            if predicate is None:
                print("%s" % object_list[0].header_plural)
                print("%s" % object_list[0].list_view_header())
                for cur_obj in object_list:
                    print(" %s" % cur_obj.list_view())
            else:
                if predicate == 'applications':
                    # list all applications
                    item_list = []
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            for vhost in machine.vhosts().values():
                                item_list += vhost.applications().values()
                    self.__ls_objects(item_list)
                elif predicate == 'licenses':
                    # list all licences
                    item_dict = {}
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            for licensekey in machine.licenses().values():
                                if licensekey not in item_dict.keys():
                                    item_dict[licensekey] = WztrLicense(licensekey)
                                item_dict[licensekey].add_server(machine)
                    self.__ls_objects(item_dict.values())
                    
        else:
            print("empty list...")
        print()
        
    def __ls_object(self, object_instance, predicate=None):
        if predicate is None:
            if isinstance(object_instance, WztrMachine):
                # machine specified, list vhosts
                self.__ls_objects(object_instance.vhosts().values())
            elif isinstance(object_instance, WztrVhost):
                # vhost specified, list applications
                self.__ls_objects(object_instance.applications().values())
        else:
            if predicate == "details":
                print("%s: %s" % (object_instance.header_singular, object_instance))
                print( self.dict_formatter( object_instance.detail_view() ) )

            elif predicate == "configuration":
                if isinstance(object_instance, WztrApplication):
                    # config of app
                    print(self.dict_formatter(object_instance.configuration()))
            elif predicate == "properties":
                if isinstance(object_instance, WztrApplication):
                    # properties (adv config) of app
                    print(self.list_formatter(object_instance.configurationAdvanced()))
    
    def complete_ls(self, text, line, begidx, endidx):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, text)
        items = [i for i in result["completion"] if i.startswith(text)]
        
        index_dict = {
                1: items
                }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)

    def do_diff(self, inp):
        input_arr = inp.split(" ")
        if len(input_arr) == 2:
            result_arg_2 = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_2, input_arr[1])
            result_arg_1 = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_1, input_arr[0])
        
            if result_arg_1["error"] is None:
                if result_arg_1["object"] is not None:
                    if isinstance(result_arg_1["object"], WztrApplication) or isinstance(result_arg_1["object"], WztrVhost):
                        if result_arg_2["error"] is None:
                            if result_arg_2["object"] is not None:
                                if isinstance(result_arg_2["object"], WztrMachine):
                                    # all objects have been provided!!
                                    
                                    target_machine = result_arg_2["object"]
                                    
                                    # replace machine name in path of source obj
                                    argument_1_arr = input_arr[0].split("/")
                                    machine_index=1
                                    if argument_1_arr[0] != "":
                                        machine_index=0
                                    
                                    if argument_1_arr[machine_index] != target_machine.name:
                                        argument_1_arr[machine_index] = target_machine.name
                                        target_path = "/".join(argument_1_arr)
                                        target_path_result = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_1, target_path)
                                        obj_1 = result_arg_1["object"]
                                        obj_2 = target_path_result["object"]
                                        if target_path_result["error"] is None and obj_2 is not None:
                                            # perform difference
                                            diffs = None
                                            if isinstance(obj_2, WztrApplication):
                                                diffs = WztrPrompt.__diff_application_configs(obj_1, obj_2)
                                            elif isinstance(obj_2, WztrVhost):
                                                # for vhost obj, perform a difference on
                                                # the list of applications
                                                diffs = []
                                                apps_1 = obj_1.applications()
                                                apps_2 = obj_2.applications()
                                                
                                                # comparing dictionaries
                                                apps_1_found_in_apps_2=[]
                                                apps_1_keys = apps_1.keys()
                                                apps_2_keys = apps_2.keys()
                                                for key_1 in apps_1_keys:
                                                    if key_1 in apps_2_keys:
                                                        apps_1_found_in_apps_2.append(key_1)
                                                        app_diffs = WztrPrompt.__diff_application_configs(apps_1[key_1], apps_2[key_1])
                                                        if len(app_diffs) > 0:
                                                            diff_state = "*** conf mismatch"
                                                    else:
                                                        # la app e' presente in apps_1 ma non in apps_2
                                                        diffs.append( {
                                                            "key": key_1,
                                                            "value_1": "app present",
                                                            "value_2": "*** no app"
                                                        })
                                                # trova le app che sono presenti in apps_2 ma non in apps_1
                                                for obj2key in obj_2_keys:
                                                    if obj2key not in obj_1_keys:
                                                        diffs.append( {
                                                            "key": obj2key,
                                                            "value_1": "*** no app",
                                                            "value_2": "app present"
                                                        })
                                                
                                                # controlla se la lista apps_2 contiene piu' elementi di apps_1
                                                while index < len(apps_2):
                                                    item2 = apps_2[index]
                                                    diffs.append( {
                                                        "key": str(item2.name),
                                                        "value_1": "*** no app",
                                                        "value_2": "app present"
                                                    })
                                                    index += 1
                                                
                                                
                                            else:
                                                print("** Error: object %s on machine %s is not an application" % (result_arg_1["object"].name, target_machine))

                                            print(WztrPrompt.diff_formatter(obj_1, obj_2, diffs))
                                            
                                        else:
                                            print("** Error: cannot find application %s on machine %s" % (result_arg_1["object"].name, target_machine))
                                    else:
                                        print("** Error: source and destination are the same")
                                else:
                                    print("** Error: %s is not a machine" % result_arg_2["object"])
                            else:
                                print("** Error: please specify an object to compare")
                        else:
                            print("** Error: %s" % result_arg_2["error"])
                    else:
                        print("** Error: %s is not an application or vhost object" % result_arg_1["object"])
                else:
                    print("** Error: please specify a source object to compare")
            else:
                print("** Error: %s" % result_arg_1["error"])
        else:
            print("** Error: usage: diff <application> <machine>")

    @staticmethod
    def __diff_application_configs(app1, app2):
        # for application objects, perform difference on config
        # and advanced config
        diff_result = WztrPrompt.config_diff(app1.configuration(), app2.configuration())
        diffs = diff_result["diffs"]
        diff_result = WztrPrompt.config_diff(app1.configurationAdvanced(), app2.configurationAdvanced())
        diffs += diff_result["diffs"]
        
        return diffs

    def complete_diff(self, text, line, begidx, endidx):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_1, text)
        items_arg_1 = [i for i in result["completion"] if i.startswith(text)]
        items_arg_2 = self.machines.keys()
        
        index_dict = {
                1: items_arg_1,
                2: items_arg_2
                }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)
            
    def help_ls(self):
        print("List items and configurations")
        print("Application list reports four flags (\"X\" means enabled, \"-\" disabled): DVR DRM Transcoders Targets")
        
    def do_refresh(self, inp):
        for machinename in self.machines.keys():
            self.machines[machinename].reset_cache()
                     
    def help_refresh(self):
        print("refresh info from servers")


    @staticmethod
    def config_diff(config_obj_1, config_obj_2):
        error=None
        diffs=[]
        if type(config_obj_1) == type(config_obj_2):
            if isinstance(config_obj_1, dict):
                # comparing dictionaries
                keys_obj1_found_in_obj2=[]
                obj_1_keys = config_obj_1.keys()
                obj_2_keys = config_obj_2.keys()
                for key_1 in obj_1_keys:
                    if key_1 in obj_2_keys:
                        keys_obj1_found_in_obj2.append(key_1)
                        result = WztrPrompt.config_diff(config_obj_1[key_1], config_obj_2[key_1])
                        for diff in result["diffs"]:
                            diff["key"] = "%s/%s" % (key_1, diff["key"])
                            diffs.append(diff)
                    else:
                        # la key e' presente in obj_1 ma non in obj_2
                        diffs.append( {
                            "key": key_1,
                            "value_1": config_obj_1[key_1],
                            "value_2": None
                        })
                # trova le key che sono presenti in obj_2 ma non in obj_1
                for obj2key in obj_2_keys:
                    if obj2key not in obj_1_keys:
                        diffs.append( {
                            "key": obj2key,
                            "value_1": None,
                            "value_2": config_obj_2[obj2key]
                        })
                        
                        
                        
            elif isinstance(config_obj_1, list):
                # comparing lists
                index = 0
                for item1 in config_obj_1:
                    if index < len(config_obj_2):
                        item2 = config_obj_2[index]
                        result = WztrPrompt.config_diff(item1, item2)
                        for diff in result["diffs"]:
                            diff["key"] = "%s/%s" % (str(index), diff["key"])
                            diffs.append(diff)
                    else:
                        # la lista config_obj_1 contiene piu' elementi di config_obj_2
                        diffs.append( {
                            "key": str(index),
                            "value_1": item1,
                            "value_2": None
                        })
                    index += 1
                    
                # cntrolla se la lista config_obj_2 contiene piu' elementio di config_obj_1
                while index < len(config_obj_2):
                    item2 = config_obj_2[index]
                    diffs.append( {
                        "key": str(index),
                        "value_1": None,
                        "value_2": item2
                    })
                    index += 1
            else:
                # assuming objects that are not lists of dicts can be compared directly
                if config_obj_1 != config_obj_2:
                    diffs.append( {
                        "key": "",
                        "value_1": config_obj_1,
                        "value_2": config_obj_2
                    })
            
        else:
            #error = "cannot compare %s with %s" % (type(config_obj_1), type(config_obj_2))
            diffs.append( {
                "key": "",
                "value_1": "type=%s" % type(config_obj_1),
                "value_2": "type=%s" % type(config_obj_2)
            })
            
        
        return {
            "diffs": diffs,
            "error": error
        }
        
    @staticmethod
    def dict_formatter(data_dict, level=0):
        output=""
        margin = "                            "[:level*2]
        for cur_key in data_dict.keys():
            if isinstance(data_dict[cur_key], dict):
                output += "%s  %-14s:\n" % (margin, cur_key)
                output += WztrPrompt.dict_formatter(data_dict[cur_key], level+1)
            elif type(data_dict[cur_key]) is list:
                if len(data_dict[cur_key]) == 0:
                    output += "%s  %-14s: []\n" % (margin, cur_key)
                else:
                    if type(data_dict[cur_key][0]) is dict:
                        output += WztrPrompt.list_formatter(data_dict[cur_key], level+1)
                    else:
                        output += "%s  %-14s: [%s]\n" % (margin, cur_key, ", ".join(data_dict[cur_key]))
            else:
                output += "%s  %-14s: %s\n" % (margin, cur_key, data_dict[cur_key])
        
        return output

    @staticmethod
    def list_formatter(data_list, level=0):
        output=""
        margin = "                            "[:level*2]
        
        output += margin + "[\n"
        for cur_item in data_list:
            output += margin + "  {\n"
            output += WztrPrompt.dict_formatter(cur_item, level+1)
            output += margin + "  }\n"
        output += margin + "]\n"
        
        return output

    @staticmethod
    def diff_formatter(obj_1, obj_2, diff_list):
        output="\n"
        if diff_list is not None:
            if len(diff_list) == 0:
                output += "  No differences found between %s and %s" % (obj_1, obj_2)
            else:
                output += "%-40s %-40s %-40s\n" % ("Key", obj_1, obj_2)
                output += "-----------------------------------------------------------------------------------------------------------------------\n"
                for cur_item in diff_list:
                    val1 = cur_item["value_1"]
                    val2 = cur_item["value_2"]
                    if isinstance(val1, list):
                        val1 = "<List>"
                    if isinstance(val1, dict):
                        val1 = "<Dict>"
                    if isinstance(val2, list):
                        val2 = "<List>"
                    if isinstance(val2, dict):
                        val2 = "<Dict>"
                    output += "%-40s %-40s %-40s\n" % (cur_item["key"], val1, val2)
        
            output += "\n"
        return output
        

p=WztrPrompt()
p.cmdloop()





