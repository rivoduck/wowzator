#!/usr/bin/python3

import httpx
import xmltodict
import json

class WztrVhost():
    def __init__(self, name, href, connectingPort, connectingIPAddress, connectingSSLEnable=False):
        self.name = name
        self.href = href
        self.connectingPort = connectingPort
        self.connectingIPAddress = connectingIPAddress
        self.connectingSSLEnable = connectingSSLEnable
    
        self.machine=None
    
    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrVhost: %s" % self.name
    
    
class WztrMachine():
    
    def __init__(self, name, address, user, pw, port=None):
        self.name=name
        self.address=address
        self.user=user
        self.pw=pw
        self.use_https=False
        self.__vhosts = None
        
        if port is not None:
            self.port=port
        else:
            self.port="8087"

    def __str__(self):
        return " %-10s (%s)" % (self.name, self.address)
    def __repr__(self):
        return "WztrMachine: %s" % self.name
    
    def __fetch(self, url):
        try:
            base_url="http://"
            if self.use_https:
                base_url="https://"
            
            base_url += self.address
            url = "%s:%s%s" % (base_url, self.port, url) 
            
            response = httpx.get(
                url,
                auth=httpx.DigestAuth(
                    self.user, self.pw
                ),
                timeout=httpx.Timeout(timeout=5)
            )
            
            return response.text

        except httpx.exceptions.ConnectTimeout:
            print('timeout getting %s on machine %s' % (url, self))
            return False
        except Exception as e:
            print('error getting %s on machine %s' % (url, self))
            print(e)
            return False
        
    def __fetchJson(self, url):
        xmlresponse = self.__fetch(url)
        
        jsonresponse = xmltodict.parse(
            xmlresponse,
            dict_constructor=dict,
            xml_attribs=True,
            force_list=('VHosts', 'VHost', 'Application', 'ApplicationInstance', 'Stream', 'MachineMonitorRequest')
        )
        
        return jsonresponse
            
            
    
    def vhosts(self):
        # lazy-fetch vhosts
        if self.__vhosts is None:
            self.__vhosts={}
            vhosts = (self.__fetchJson("/v2/servers/_defaultServer_/vhosts"))
            if 'VHosts' in vhosts.keys():
                for vhost_entry in vhosts['VHosts']:
                    vhost = vhost_entry['Vhost']
                    newvh = WztrVhost(vhost['@id'], vhost['@href'], vhost['@connectingIPAddress'], vhost['@connectingPort'], vhost['@connectingSSLEnable'])
                    newvh.machine = self
                    
                    self.__vhosts[newvh.name] = newvh

        return self.__vhosts









from cmd2 import Cmd
import json, sys

_CONFIGFILE="config.json"





class WztrPrompt(Cmd):
    prompt = 'wowzator> '
    intro = "\nWowzator: a simple Wowza Configuration Manager by Top-IX\nType ? to list commands, TAB to autocomplete\n"
    
    syntaxtree_ls = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "vhosts",
                    "keyword_type": "predicate",
                    "syntaxtree": [ 
                        { 
                            "keyword": "$VHOST",
                            "keyword_type": "object",
                            "syntaxtree": [
                                {
                                    "keyword": "applications",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                },
                                {
                                    "keyword": "transcoders",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                }
                            ]
                        } 
                    ]
                } 
            ]
        },
        {
            "keyword": "$ALL_MACHINES",
            "keyword_type": "multi_object",
            "syntaxtree": []
        }
    ]
    
    
    def __init__(self):
        print("initializing...")
        Cmd.__init__(self)
        
        self.machines = {}
        
        try:
            with open(_CONFIGFILE) as json_file:
                machines_config = json.load(json_file)
        
                for machine_config in machines_config:
                    machine=WztrMachine(name=machine_config["name"], address=machine_config["address"], user=machine_config["user"], pw=machine_config["pw"])
                    self.machines[machine.name]=machine
            

        except Exception as e:
            print(e)
            print("Cannot open %s" % _CONFIGFILE)
            sys.exit(-1)
    
    def do_exit(self, inp):
        print('Bye')
        return True
    
    do_EOF=do_exit

    def do_ls(self, inp):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, inp)
        
        print(result)
        '''
                    print("Machines:")
                    for machinename in self.machines.keys():
                        machine=self.machines[machinename]
                        print(" %s" % machine)
        '''
                    
    # return an array of objects or a single instance depending on what the path points to
    def __get_obj_by_path(self, syntax_tree, path):
        self.command_object = None
        self.command_objects = None
        self.command_predicate = None
        self.command_error = None
        
        completion = []
        
        
        path_arr = path.split("/")
        
        removed_trailing_slash = False
        removed_leading_slash = False
        # set to True by default to deal with empty path
        # if path is provided it will be immediately set to False when path is parsed
        keyword_matched = True
        
        # remove last and first elements of path if empty
        if len(path_arr) > 0 and path_arr[-1] == "":
            path_arr.pop()
            removed_trailing_slash = True
        if len(path_arr) > 0 and path_arr[0] == "":
            path_arr.pop(0)
            removed_leading_slash = True
        
        expanded_syntax_tree = self.__expand_keywords(syntax_tree)
        cur_path_pos = 0
        for cur_path_el in path_arr:
            
            keyword_matched = False
            for syntax_el in expanded_syntax_tree:
                if cur_path_el == syntax_el["keyword"]:

                    if syntax_el["keyword_type"] == "object":
                        self.command_object = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "multi_object":
                        self.command_objects = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "predicate":
                        self.command_predicate = syntax_el["keyword"]

                    # move down syntax tree
                    expanded_syntax_tree = self.__expand_keywords(syntax_el["syntaxtree"])
                    keyword_matched = True
            
            if not keyword_matched:
                command_error = "%s: keyword not recognized" % cur_path_el
                cur_path = "/".join(path_arr[:cur_path_pos])
                if cur_path != "":
                    cur_path += "/"
                if removed_leading_slash:
                    cur_path = "/" + cur_path
            
                for syntax_el in expanded_syntax_tree:
                    completion.append( cur_path + syntax_el["keyword"] )
                    if len(syntax_el["syntaxtree"]) > 0:
                        completion.append( cur_path + syntax_el["keyword"] +"/" )

                break
            
                
            cur_path_pos += 1
                
        if keyword_matched:
            cur_path = "/".join(path_arr[:cur_path_pos])
            if cur_path != "":
                cur_path += "/"
            if removed_leading_slash:
                cur_path = "/" + cur_path
        
            for syntax_el in expanded_syntax_tree:
                completion.append( cur_path + syntax_el["keyword"] )
                if len(syntax_el["syntaxtree"]) > 0:
                    completion.append( cur_path + syntax_el["keyword"] +"/" )
            
                        
            
        
        
        return {
            "object": self.command_object,
            "objects": self.command_objects,
            "predicate": self.command_predicate,
            "error": self.command_error,
            "completion": completion
        }

    
    # expand macro keywords in first level of syntax tree
    def __expand_keywords(self, syntax_tree):
        expanded_syntax_tree = []
        for syntax_el in syntax_tree:
            kw = syntax_el["keyword"]
            if kw[0] == "$":
                expanded_dict = self.__expand_keyword_macro(kw)
                for expanded_kw in expanded_dict.keys():
                    exp_syntax_el = {
                        "keyword": expanded_kw,
                        "keyword_type": syntax_el["keyword_type"],
                        "syntaxtree": syntax_el["syntaxtree"],
                        "data": expanded_dict[expanded_kw]
                    }
                    expanded_syntax_tree.append(exp_syntax_el)
            else:
                expanded_syntax_tree.append(syntax_el)
        
        return expanded_syntax_tree
    
    
    
    
    # expand individual macro
    def __expand_keyword_macro(self, keyword):
        expanded_dict = {}
        if keyword == "$MACHINE":
            expanded_dict = self.machines
            #for machine_name in self.machines.keys():
            #    expanded_dict[machine_name]=self.machines[machine_name]
        elif keyword == "$ALL_MACHINES":
            expanded_dict["all"]=self.machines.values()
        elif keyword == "$VHOST":
            expanded_dict = self.command_object.vhosts()
        
        return expanded_dict


    
    
    def complete_ls(self, text, line, begidx, endidx):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, text)
        
        return [i for i in result["completion"] if i.startswith(text)]
        
    def help_ls(self):
        print("List items and configurations")
        
    def do_refresh(self, inp):
        for machinename in self.machines.keys():
            machine=self.machines[machinename]
            machine.__vhosts = None
    def help_refresh(self):
        print("refresh info from servers")




p=WztrPrompt()
p.cmdloop()






    
    
