#!/usr/bin/python3

import httpx
import xmltodict
import json



class WztrApplication():
    header_singular="Application"
    header_plural="Applications"

    def __init__(self, name, href, appType, dvrEnabled=False, drmEnabled=False, transcoderEnabled=False, streamtargetsEnabled=False):
        self.name = name
        self.href = href
        self.appType = appType

        if dvrEnabled == "true":
            self.dvrEnabled = True
        else:
            self.dvrEnabled = False
        if drmEnabled == "true":
            self.drmEnabled = True
        else:
            self.drmEnabled = False
        if transcoderEnabled == "true":
            self.transcoderEnabled = True
        else:
            self.transcoderEnabled = False
        if streamtargetsEnabled == "true":
            self.streamtargetsEnabled = True
        else:
            self.streamtargetsEnabled = False
    
        self.vhost=None
        self.__configuration = None
    
    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrVhost: %s" % self.name
    def list_view(self):
        return "%-10s %1s%1s%1s%1s  /%s/%s/%s" % (self.appType, 
            "X" if self.dvrEnabled else "-", "X" if self.drmEnabled else "-",
            "X" if self.transcoderEnabled else "-", "X" if self.streamtargetsEnabled else "-",
            self.vhost.machine.name, self.vhost.name, self.name)
    def detail_view(self):
        return {
            "App Type": self.appType,
            "Server": "/%s/%s/%s" % (self.vhost.machine.name, self.vhost.name, self.name),
            "DVR": "** ON" if self.dvrEnabled else "OFF",
            "DRM": "** ON" if self.drmEnabled else "OFF",
            "Transcoder": "** ON" if self.transcoderEnabled else "OFF",
            "Targets": "** ON" if self.streamtargetsEnabled else "OFF"
        }


    def configuration(self):
        # lazy-fetch application config
        if self.__configuration is None:
            self.__configuration={}

            result = self.vhost.machine.fetchJson(self.href)
            if 'Application' in result.keys():
                entry = result['Application']
                self.__configuration = entry

        return self.__configuration
        
        
        
class WztrVhost():
    header_singular="VHost"
    header_plural="VHosts"

    def __init__(self, name, href, connectingIPAddress, connectingPort, connectingSSLEnable=False):
        self.name = name
        self.href = href
        self.connectingPort = connectingPort
        self.connectingIPAddress = connectingIPAddress
        if connectingSSLEnable == "true":
            self.connectingSSLEnable = True
        else:
            self.connectingSSLEnable = False
    
        self.__applications = None
        self.machine=None
    
    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrVhost: %s" % self.name
    def list_view(self):
        return str(self)
    def detail_view(self):
        return {
            "Machine": str(self.machine),
            "Addr/Port": "%s/%s" % (self.connectingIPAddress, self.connectingPort),
            "SSL": "YES" if self.connectingSSLEnable else "NO",
        }
    
    
    def applications(self):
        # lazy-fetch applications
        if self.__applications is None:
            self.__applications={}
            result = self.machine.fetchJson("/v2/servers/_defaultServer_/vhosts/%s/applications" % self.name)

            if 'Applications' in result.keys():
                entry = result['Applications']
                if 'Application' in entry.keys():
                    item_list = entry['Application']
                    for item in item_list:
                        newapp = WztrApplication(item['@id'], item['@href'], item['AppType'], item['DVREnabled'], item['DRMEnabled'], item['TranscoderEnabled'], item['StreamTargetsEnabled'])
                        newapp.vhost = self
                    
                        self.__applications[newapp.name] = newapp

        return self.__applications
    
    
class WztrMachine():
    header_singular="Machine"
    header_plural="Machines"
    
    def __init__(self, name, address, user, pw, port=None):
        self.name=name
        self.address=address
        self.user=user
        self.pw=pw
        self.use_https=False
        self.__vhosts = None
        self.__version = None
        
        if port is not None:
            self.port=port
        else:
            self.port="8087"

    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrMachine: %s" % self.name
    def list_view(self):
        return " %-8s %-17s [%s]" % (self.name, "(" + self.address + ")", self.version())
    def detail_view(self):
        return {
            "Address": self.address,
            "Version": self.version(),
            "HTTPS": "YES" if self.use_https else "NO",
            "Credentials": {
                "user": self.user,
                "pw": "*******"
            }
        }
        
    def fetch(self, url):
        try:
            base_url="http://"
            if self.use_https:
                base_url="https://"
            
            base_url += self.address
            url = "%s:%s%s" % (base_url, self.port, url) 
            
            response = httpx.get(
                url,
                auth=httpx.DigestAuth(
                    self.user, self.pw
                ),
                timeout=httpx.Timeout(timeout=5)
            )
            
            return response.text

        except httpx.exceptions.ConnectTimeout:
            print('timeout getting %s on machine %s' % (url, self))
            return False
        except Exception as e:
            print('error getting %s on machine %s' % (url, self))
            print(e)
            return False
        
    def fetchJson(self, url):
        xmlresponse = self.fetch(url)
        
        jsonresponse = xmltodict.parse(
            xmlresponse,
            dict_constructor=dict,
            xml_attribs=True,
            force_list=('VHosts', 'VHost', 'Application', 'ApplicationInstance', 'Stream', 'MachineMonitorRequest')
        )
        
        return jsonresponse
    
    
    def reset_cache(self):
        self.__vhosts = None
        self.__version = None
    
    def vhosts(self):
        # lazy-fetch vhosts
        if self.__vhosts is None:
            self.__vhosts={}
            vhosts = (self.fetchJson("/v2/servers/_defaultServer_/vhosts"))
            if 'VHosts' in vhosts.keys():
                for vhost_entry in vhosts['VHosts']:
                    vhost = vhost_entry['Vhost']
                    newvh = WztrVhost(vhost['@id'], vhost['@href'], vhost['@connectingIPAddress'], vhost['@connectingPort'], vhost['@connectingSSLEnable'])
                    newvh.machine = self
                    
                    self.__vhosts[newvh.name] = newvh

        return self.__vhosts

    def version(self):
        # lazy-fetch version
        if self.__version is None:
            self.__version = "*** No connection ***"
            try:
                self.__version = (self.fetch(""))
            
            except:
                pass
        
        return self.__version





from cmd2 import Cmd
import json, sys

_CONFIGFILE="config.json"





class WztrPrompt(Cmd):
    prompt = 'wowzator> '
    intro = "\nWowzator: a simple Wowza Configuration Manager by Top-IX\nType ? to list commands, TAB to autocomplete\n"
    
    syntaxtree_ls = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "vhosts",
                    "keyword_type": "predicate",
                    "syntaxtree": [ 
                        { 
                            "keyword": "$VHOST",
                            "keyword_type": "object",
                            "syntaxtree": [
                                {
                                    "keyword": "applications",
                                    "keyword_type": "predicate",
                                    "syntaxtree": [
                                        {
                                            "keyword": "$APPLICATION",
                                            "keyword_type": "object",
                                            "syntaxtree": [
                                                {
                                                    "keyword": "configuration",
                                                    "keyword_type": "predicate",
                                                    "syntaxtree": []
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "keyword": "transcoders",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                }
                            ]
                        } 
                    ]
                } 
            ]
        },
        {
            "keyword": "$ALL_MACHINES",
            "keyword_type": "multi_object",
            "syntaxtree": []
        }
    ]
    
    
    def __init__(self):
        print("initializing...")
        Cmd.__init__(self)
        
        self.machines = {}
        
        try:
            with open(_CONFIGFILE) as json_file:
                machines_config = json.load(json_file)
        
                for machine_config in machines_config:
                    machine=WztrMachine(name=machine_config["name"], address=machine_config["address"], user=machine_config["user"], pw=machine_config["pw"])
                    self.machines[machine.name]=machine
            

        except Exception as e:
            print(e)
            print("Cannot open %s" % _CONFIGFILE)
            sys.exit(-1)
    
    def do_exit(self, inp):
        print('Bye')
        return True
    
    do_EOF=do_exit

                    
    # return an array of objects or a single instance depending on what the path points to
    def __get_obj_by_path(self, syntax_tree, path):
        self.command_object = None
        self.command_objects = None
        self.command_predicate = None
        self.command_error = None
        
        completion = []
        
        
        path_arr = path.split("/")
        
        removed_trailing_slash = False
        removed_leading_slash = False
        # set to True by default to deal with empty path
        # if path is provided it will be immediately set to False when path is parsed
        keyword_matched = True
        
        # remove last and first elements of path if empty
        if len(path_arr) > 0 and path_arr[-1] == "":
            path_arr.pop()
            removed_trailing_slash = True
        if len(path_arr) > 0 and path_arr[0] == "":
            path_arr.pop(0)
            removed_leading_slash = True
        
        expanded_syntax_tree = self.__expand_keywords(syntax_tree)
        cur_path_pos = 0
        for cur_path_el in path_arr:
            
            keyword_matched = False
            for syntax_el in expanded_syntax_tree:
                if cur_path_el == syntax_el["keyword"]:

                    if syntax_el["keyword_type"] == "object":
                        self.command_object = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "multi_object":
                        self.command_objects = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "predicate":
                        self.command_predicate = syntax_el["keyword"]

                    # move down syntax tree
                    expanded_syntax_tree = self.__expand_keywords(syntax_el["syntaxtree"])
                    keyword_matched = True
            
            if not keyword_matched:
                self.command_error = "%s: keyword not recognized" % cur_path_el
                cur_path = "/".join(path_arr[:cur_path_pos])
                if cur_path != "":
                    cur_path += "/"
                if removed_leading_slash:
                    cur_path = "/" + cur_path
            
                for syntax_el in expanded_syntax_tree:
                    completion.append( cur_path + syntax_el["keyword"] )
                    if len(syntax_el["syntaxtree"]) > 0:
                        completion.append( cur_path + syntax_el["keyword"] +"/" )

                break
            
                
            cur_path_pos += 1
                
        if keyword_matched:
            cur_path = "/".join(path_arr[:cur_path_pos])
            if cur_path != "":
                cur_path += "/"
            if removed_leading_slash:
                cur_path = "/" + cur_path
        
            for syntax_el in expanded_syntax_tree:
                completion.append( cur_path + syntax_el["keyword"] )
                if len(syntax_el["syntaxtree"]) > 0:
                    completion.append( cur_path + syntax_el["keyword"] +"/" )
            
                        
            
        
        
        return {
            "object": self.command_object,
            "objects": self.command_objects,
            "predicate": self.command_predicate,
            "error": self.command_error,
            "completion": completion
        }

    
    # expand macro keywords in first level of syntax tree
    def __expand_keywords(self, syntax_tree):
        expanded_syntax_tree = []
        for syntax_el in syntax_tree:
            kw = syntax_el["keyword"]
            if kw[0] == "$":
                expanded_dict = self.__expand_keyword_macro(kw)
                for expanded_kw in expanded_dict.keys():
                    exp_syntax_el = {
                        "keyword": expanded_kw,
                        "keyword_type": syntax_el["keyword_type"],
                        "syntaxtree": syntax_el["syntaxtree"],
                        "data": expanded_dict[expanded_kw]
                    }
                    expanded_syntax_tree.append(exp_syntax_el)
            else:
                expanded_syntax_tree.append(syntax_el)
        
        return expanded_syntax_tree
    
    
    
    
    # expand individual macro
    def __expand_keyword_macro(self, keyword):
        expanded_dict = {}
        if keyword == "$MACHINE":
            expanded_dict = self.machines
            #for machine_name in self.machines.keys():
            #    expanded_dict[machine_name]=self.machines[machine_name]
        elif keyword == "$ALL_MACHINES":
            expanded_dict["all"]=self.machines.values()
        elif keyword == "$VHOST":
            expanded_dict = self.command_object.vhosts()
        elif keyword == "$APPLICATION":
            expanded_dict = self.command_object.applications()
        
        return expanded_dict


    def do_ls(self, inp):
        print()
        
        self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, inp)
        
        if self.command_error is None:
            if self.command_object is None:
                if self.command_objects is None:
                    self.__ls_objects(self.machines.values(), self.command_predicate)
                else:
                    self.__ls_objects(self.command_objects, self.command_predicate)
            else:
                self.__ls_object(self.command_object, self.command_predicate)
        else:
            print("** Error: %s" % self.command_error)

    def __ls_objects(self, object_list, predicate=None):
        object_list = list(object_list)
        if len(object_list) > 0:
            print("%s" % object_list[0].header_plural)
            for cur_obj in object_list:
                print(" %s" % cur_obj.list_view())
        else:
            print("empty list...")
        print()
        
    def __ls_object(self, object_instance, predicate=None):
        if predicate is None:
            print("%s: %s" % (object_instance.header_singular, object_instance))
            print( self.detail_formatter( object_instance.detail_view() ) )
        else:
            if predicate == "vhosts":
                if isinstance(object_instance, WztrVhost):
                    # details of vhost
                    self.__ls_object(object_instance)
                else:
                    self.__ls_objects(object_instance.vhosts().values())
            elif predicate == "applications":
                if isinstance(object_instance, WztrApplication):
                    # details of app
                    self.__ls_object(object_instance)
                else:
                    self.__ls_objects(object_instance.applications().values())
            elif predicate == "configuration":
                if isinstance(object_instance, WztrApplication):
                    # config of app
                    print(detail_formatter(object_instance.configuration()))
    
    def complete_ls(self, text, line, begidx, endidx):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, text)
        
        return [i for i in result["completion"] if i.startswith(text)]
        
    def help_ls(self):
        print("List items and configurations")
        print("Application list reports four flags (\"X\" means enabled, \"-\" disabled): DVR DRM Transcoders Targets")
        
    def do_refresh(self, inp):
        for machinename in self.machines.keys():
            self.machines[machinename].reset_cache()
                     
    def help_refresh(self):
        print("refresh info from servers")


    @staticmethod
    def detail_formatter(data_dict, level=0):
        output=""
        margin = "                            "[:level*2]
        for cur_key in data_dict.keys():
            if isinstance(data_dict[cur_key], dict):
                output += "%s  %-12s:\n" % (margin, cur_key)
                output += WztrPrompt.detail_formatter(data_dict[cur_key], level+1)
            elif type(data_dict[cur_key]) is list:
                output += "%s  %-12s: [%s]\n" % (margin, cur_key, ", ".join(data_dict[cur_key]))
            else:
                output += "%s  %-12s: %s\n" % (margin, cur_key, data_dict[cur_key])
        
        return output


p=WztrPrompt()
p.cmdloop()





