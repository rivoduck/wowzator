#!/usr/bin/python3

import httpx
import xmltodict
import json

class WztrVhost():
    def __init__(self, name, href, connectingPort, connectingIPAddress, connectingSSLEnable=False):
        self.name = name
        self.href = href
        self.connectingPort = connectingPort
        self.connectingIPAddress = connectingIPAddress
        self.connectingSSLEnable = connectingSSLEnable
    
        self.machine=None
    
    def __str__(self):
        return self.name
    def __repr__(self):
        return str(self)
    
    
class WztrMachine():
    
    def __init__(self, name, address, user, pw, port=None):
        self.name=name
        self.address=address
        self.user=user
        self.pw=pw
        self.use_https=False
        self.__vhosts = None
        
        if port is not None:
            self.port=port
        else:
            self.port="8087"

    def __str__(self):
        return " %-10s (%s)" % (self.name, self.address)
    
    
    def __fetch(self, url):
        try:
            base_url="http://"
            if self.use_https:
                base_url="https://"
            
            base_url += self.address
            url = "%s:%s%s" % (base_url, self.port, url) 
            
            response = httpx.get(
                url,
                auth=httpx.DigestAuth(
                    self.user, self.pw
                ),
                timeout=httpx.Timeout(timeout=5)
            )
            
            return response.text

        except httpx.exceptions.ConnectTimeout:
            print('timeout getting %s on machine %s' % (url, self))
            return False
        except Exception as e:
            print('error getting %s on machine %s' % (url, self))
            print(e)
            return False
        
    def __fetchJson(self, url):
        xmlresponse = self.__fetch(url)
        
        jsonresponse = xmltodict.parse(
            xmlresponse,
            dict_constructor=dict,
            xml_attribs=True,
            force_list=('VHosts', 'VHost', 'Application', 'ApplicationInstance', 'Stream', 'MachineMonitorRequest')
        )
        
        return jsonresponse
            
            
    
    def vhosts(self):
        # lazy-fetch vhosts
        if self.__vhosts is None:
            self.__vhosts={}
            vhosts = (self.__fetchJson("/v2/servers/_defaultServer_/vhosts"))
            if 'VHosts' in vhosts.keys():
                for vhost_entry in vhosts['VHosts']:
                    vhost = vhost_entry['Vhost']
                    newvh = WztrVhost(vhost['@id'], vhost['@href'], vhost['@connectingIPAddress'], vhost['@connectingPort'], vhost['@connectingSSLEnable'])
                    newvh.machine = self
                    
                    self.__vhosts[newvh.name] = newvh

        return self.__vhosts









from cmd2 import Cmd
import json, sys

_CONFIGFILE="config.json"





class WztrPrompt(Cmd):
    prompt = 'wowzator> '
    intro = "\nWowzator: a simple Wowza Configuration Manager by Top-IX\nType ? to list commands, TAB to autocomplete\n"
    
    syntaxtree_ls = [
        {
            "keywords": [ ("$MACHINE", "object"), ("$ALL_MACHINES", "objects") ],
            "syntaxtree": [ 
                { 
                    "keywords": [ ("vhosts", "predicate") ],
                    "syntaxtree": [ 
                        { 
                            "keywords": [ ("$VHOST", "object") ],
                            "syntaxtree": [
                                {
                                    "keywords": [ ("applications", "predicate") ],
                                    "syntaxtree": []
                                },
                                {
                                    "keywords": [ ("transcoders", "predicate") ],
                                    "syntaxtree": []
                                }
                            ]
                        } 
                    ]
                } 
            ]
        }
    ]
    
    
    def __init__(self):
        print("initializing...")
        Cmd.__init__(self)
        
        self.machines = {}
        
        try:
            with open(_CONFIGFILE) as json_file:
                machines_config = json.load(json_file)
        
                for machine_config in machines_config:
                    machine=WztrMachine(name=machine_config["name"], address=machine_config["address"], user=machine_config["user"], pw=machine_config["pw"])
                    self.machines[machine.name]=machine
            

        except Exception as e:
            print(e)
            print("Cannot open %s" % _CONFIGFILE)
            sys.exit(-1)
    
    def do_exit(self, inp):
        print('Bye')
        return True
    
    do_EOF=do_exit

    def do_ls(self, inp):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, inp)
        
        print(result)
        '''
                    print("Machines:")
                    for machinename in self.machines.keys():
                        machine=self.machines[machinename]
                        print(" %s" % machine)
        '''
                    
    # return an array of objects or a single instance depending on what the path points to
    def __get_obj_by_path(self, syntax_tree, path):
        command_object = None
        command_objects = None
        command_predicate = None
        command_error = None
        
        completion = []
        
        
        path_arr = path.split("/")
        
        removed_trailing_slash = False
        removed_leading_slash = False
        
        # remove last and first elements of path if empty
        if len(path_arr) > 0 and path_arr[-1] == "":
            path_arr.pop()
            removed_trailing_slash = True
        if len(path_arr) > 0 and path_arr[0] == "":
            path_arr.pop(0)
            removed_leading_slash = True
        
        cur_path_pos = 0
        for cur_path_el in path_arr:
            
            for syntax_el in syntax_tree:
                # expand macro keywords
                expanded_keywords = []
                for kw_tuple in syntax_el["keywords"]:
                    kw = kw_tuple[0]
                    if kw[0] == "$":
                        expanded_keywords += self.__expand_keyword(kw_tuple)
                    else:
                        expanded_keywords.append(kw_tuple)
                
                keyword_matched = False
                # find current syntax element among the expanded keyords
                for kw_tuple in expanded_keywords:
                    if cur_path_el == kw_tuple[0]:
                        keyword_matched = True
                        if kw_tuple[1] == "object":
                            command_object = kw_tuple[2]
                        elif kw_tuple[1] == "objects":
                            command_objects = kw_tuple[2]
                        elif kw_tuple[1] == "predicate":
                            command_predicate = kw_tuple[0]
                        syntax_tree = syntax_el["syntaxtree"]
                        break
                if not keyword_matched:
                    command_error = "%s: keyword not recognized" % cur_path_el
                    cur_path = "/".join(path_arr[:cur_path_pos])
                    if cur_path != "":
                        cur_path += "/"
                    if removed_leading_slash:
                        cur_path = "/" + cur_path
                    for kw_tuple in expanded_keywords:
                        completion.append( cur_path + kw_tuple[0] )
            cur_path_pos += 1
        
        
        
        return {
            "object": command_object,
            "objects": command_objects,
            "predicate": command_predicate,
            "error": command_error,
            "completion": completion
        }

    
    def __expand_keyword(self, kw_tuple):
        expanded = []
        kw = kw_tuple[0]
        kw_type = kw_tuple[1]
        if kw == "$MACHINE":
            for machine_name in self.machines.keys():
                expanded.append( (machine_name, kw_type, self.machines[machine_name]) )
        elif kw == "$ALL_MACHINES":
            expanded.append( ("all", kw_type, self.machines.values()) )
        
        
        return expanded


    
    
    def complete_ls(self, text, line, begidx, endidx):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, text)
        
        return [i for i in result["completion"] if i.startswith(text)]
        
    def help_ls(self):
        print("List items and configurations")
        
    def do_refresh(self, inp):
        for machinename in self.machines.keys():
            machine=self.machines[machinename]
            machine.__vhosts = None
    def help_refresh(self):
        print("refresh info from servers")




p=WztrPrompt()
p.cmdloop()






    
    
