#!/usr/bin/python3

import httpx
from httpx._exceptions import NetworkError
import xmltodict
import json
from urllib.parse import quote_plus, unquote


class WztrApplication():
    header_singular="Application"
    header_plural="Applications"

    def __init__(self, name, href, appType, dvrEnabled=False, drmEnabled=False, transcoderEnabled=False, streamtargetsEnabled=False):
        self.name = name
        self.href = href
        self.appType = appType

        if dvrEnabled == "true":
            self.dvrEnabled = True
        else:
            self.dvrEnabled = False
        if drmEnabled == "true":
            self.drmEnabled = True
        else:
            self.drmEnabled = False
        if transcoderEnabled == "true":
            self.transcoderEnabled = True
        else:
            self.transcoderEnabled = False
        if streamtargetsEnabled == "true":
            self.streamtargetsEnabled = True
        else:
            self.streamtargetsEnabled = False
    
        self.vhost=None
        self.__configuration = None
        self.__configurationAdv = None # this is how app Properties are called in wowza APIs
        self.__smilfiles = None
        
    def __str__(self):
        return "/%s/%s/%s" % (self.vhost.machine.name, self.vhost.name, self.name)
    def __repr__(self):
        return "WztrApplication: %s" % self.name

    @staticmethod
    def list_view_header():
        return "%-8s %-28s %1s%1s%1s%1s" % ("App Type", "Stream Type", "(DVR)", "(DRM)", "(TRC)", "(STG)")
    def list_view(self):
        stream_type="n/a"
        config_dict = self.configuration()
        if config_dict is not None and 'StreamConfig' in config_dict.keys() and 'StreamType' in config_dict['StreamConfig'].keys():
            stream_type = config_dict['StreamConfig']['StreamType']
        
        return "%-8s %-28s %1s%1s%1s%1s  /%s/%s/apps/%s" % (self.appType, stream_type,
            "X" if self.dvrEnabled else "-", "X" if self.drmEnabled else "-",
            "X" if self.transcoderEnabled else "-", "X" if self.streamtargetsEnabled else "-",
            self.vhost.machine.name, self.vhost.name, self.name)
    def detail_view(self):
        stream_type="n/a"
        content_dir="n/a"
        origin_url=None
        config_dict = self.configuration()

        if config_dict is not None:
            if 'StreamConfig' in config_dict.keys():
                if 'StreamType' in config_dict['StreamConfig'].keys():
                    stream_type = config_dict['StreamConfig']['StreamType']
                if 'StorageDir' in config_dict['StreamConfig'].keys():
                    content_dir = config_dict['StreamConfig']['StorageDir']
            if 'RepeaterOriginURL' in config_dict.keys():
                origin_url = config_dict['RepeaterOriginURL']
                
    
        result = {
            "Server": "%s / %s" % (self.vhost.machine.name, self.vhost.name),
            "App/Stream type": self.appType + " / " + stream_type,
        }
        
        if origin_url is not None:
            result["Origin URL"] = origin_url
            
        result["Content Dir."] = content_dir
        result["DVR"] = "** ON" if self.dvrEnabled else "OFF"
        result["DRM"] = "** ON" if self.drmEnabled else "OFF"
        result["Transcoder"] = "** ON" if self.transcoderEnabled else "OFF"
        result["Targets"] = "** ON" if self.streamtargetsEnabled else "OFF"
        
        return result


    def configuration(self):
        # lazy-fetch application config
        if self.__configuration is None:
            self.__configuration={}

            result = self.vhost.machine.fetchDict(self.href)
            if result["status"] == "OK":
                if 'Application' in result["data"].keys():
                    entry = result["data"]['Application']
                
                    if 'Version' in entry.keys():
                        del entry['Version']
                
                
                    if not self.dvrEnabled and 'DVRConfig' in entry.keys():
                        del entry['DVRConfig']
                    if not self.drmEnabled and 'DRMConfig' in entry.keys():
                        del entry['DRMConfig']
                    if not self.transcoderEnabled and 'TranscoderConfig' in entry.keys():
                        del entry['TranscoderConfig']
                
                    self.__configuration = WztrApplication.__clean_config_dict(entry)

        return self.__configuration
    
    @staticmethod
    # recursively remove irrelevant items from configuration dictionary
    def __clean_config_dict(config_dict, previousKey=None):
        if '@serverName' in config_dict.keys():
            del config_dict['@serverName']
        
        if previousKey == "TranscoderConfig" and "Templates" in config_dict.keys():
            del config_dict['Templates']
            
        for key in config_dict.keys():
            if isinstance(config_dict[key], dict):
                cleanitem = WztrApplication.__clean_config_dict(config_dict[key], key)
                config_dict[key] = cleanitem
        return config_dict
        
    # in wowza APIs, application Properties are referred to as application/advanced
    def configurationAdvanced(self):
        # lazy-fetch application advanced config
        if self.__configurationAdv is None:
            self.__configurationAdv={}
            
            result = self.vhost.machine.fetchDict(self.href + "/adv")
            if result["status"] == "OK":
                if 'ApplicationAdv' in result["data"].keys():
                    if 'AdvancedSettings' in result["data"]['ApplicationAdv'].keys():
                        advSettings = result["data"]['ApplicationAdv']['AdvancedSettings']
                        if 'AdvancedSetting' in advSettings.keys():
                            # show only active properties
                            properties=[]
                            for prop in advSettings['AdvancedSetting']:
                                if prop['@enabled'] == 'true':
                                    
                                    shortprop = {
                                        'Name': prop['Name'],
                                        'Type': prop['Type'],
                                        'Value': "",
                                        'SectionName': "",
                                        'Section': ""
                                    
                                    }
                                    if 'Value' in prop.keys():
                                        shortprop['Value'] = prop['Value']
                                    if 'Section' in prop.keys():
                                        shortprop['Section'] = prop['Section']
                                    if 'SectionName' in prop.keys():
                                        shortprop['SectionName'] = prop['SectionName']
                            
                                    properties.append(shortprop)
                            
                            self.__configurationAdv=properties

        return self.__configurationAdv

    # SMIL files are taken from the application so that files in the application-specific
    # content directory are taken into account, this generates a lot of duplicates in memory
    # but it is needed for accurate results
    def smilfiles(self):
        # lazy-fetch smil file list
        if self.__smilfiles is None:
            self.__smilfiles={}
            
            result = self.vhost.machine.fetchDict(self.href + "/smilfiles")
            if result["status"] == "OK":
                if 'SMILFiles' in result["data"].keys():
                    entry = result["data"]['SMILFiles']
                    if 'SMILFile' in entry.keys():
                        items = entry['SMILFile']
                        if type(items) is not list:
                            items = [ items ];
                        for item in items:
                            newobj = WztrSmilFile(item['@id'], item['@href'])
                            newobj.application = self
        
                            self.__smilfiles[newobj.name] = newobj
                
        return self.__smilfiles
                
    def getInstanceList(self):
        # always return fresh data
        instances=[]

        result = self.vhost.machine.fetchDict(self.href + "/instances")

        if result["status"] == "OK":
            if 'Instances' in result["data"].keys():
                if 'InstanceList' in result["data"]["Instances"].keys():
                    instances = result["data"]["Instances"]["InstanceList"]
                    if not isinstance(instances, list):
                        instances = [ instances ]
        return instances

    def incomingstreams(self):
        # no lazy-fetch for incomingstreams
        # always return fresh data
        incomingstream_dict={}

        for instance in self.getInstanceList():
            if 'IncomingStreams' in instance.keys():
                if instance['IncomingStreams'] is not None:
                    if 'IncomingStream' in instance['IncomingStreams'].keys():
                        incomingstreams = instance['IncomingStreams']['IncomingStream']
                        if not isinstance(incomingstreams, list):
                            incomingstreams = [ incomingstreams ]
                        for incomingstream in incomingstreams:
                            newincoming = WztrIncomingStream(
                                incomingstream['Name'], instance['Name'], 
                                incomingstream['SourceIp'],incomingstream['IsRecordingSet'], 
                                incomingstream['IsStreamManagerStream'], incomingstream['IsPublishedToVOD'], 
                                incomingstream['IsConnected'])
                            newincoming.application = self
                            incomingstream_dict[str(newincoming)] = newincoming
                                

        return incomingstream_dict


    # ricarica la playlist del modulo StreamPublisher
    def playlist_reload(self):
        self.playlist_manage("load")

    # fa unload della playlist del modulo StreamPublisher
    def playlist_unload(self):
        self.playlist_manage("unload")

    # ricarica o fa unload della playlist del modulo StreamPublisher
    def playlist_manage(self, action="load"):
        # ricarica la configurazione e le proprietà dell'applicazione
        self.reset_config_properties()
        
        conf_StorageDir="(not defined)/"
        # cerca la definizione di StorageDir
        if 'StreamConfig' in self.configuration().keys():
            if 'StorageDir' in self.configuration()['StreamConfig'].keys():
                conf_StorageDir=self.configuration()['StreamConfig']['StorageDir']
                if conf_StorageDir[-1] != '/':
                    conf_StorageDir += '/'
            
        
        conf_streamPublisherSmilFile="streamschedule.smil"
        # cerca la proprietà streamPublisherSmilFile
        for prop in self.configurationAdvanced():
            if prop['Name'] == 'streamPublisherSmilFile':
                if prop['Type'] == 'String':
                    conf_streamPublisherSmilFile=prop['Value']
                else:
                    print("*** Warning: property %s should be type String but is type streamPublisherSmilFile instead!!!")
                
        result=None
        if action == "load":
            result = self.vhost.machine.fetchDict("/schedules?appName=%s&action=loadSchedule" % (self.name), "8086")
        elif action == "unload":
            result = self.vhost.machine.fetchDict("/schedules?appName=%s&action=unloadSchedule" % (self.name), "8086")
        else:
            print("!!internal error: action [%s] is not recognized!!")
            return
        
        action_status="na"
        action_message="no message..."
                
        if 'status' in result:
            action_status = result["status"]
        
        if 'html' in result["data"]:
            if 'body' in result["data"]['html']:
                action_message = result["data"]['html']['body']
        print("server: %s" % self.vhost.machine.name)
        print("  file: %s%s\n" %(conf_StorageDir, conf_streamPublisherSmilFile))
        print("going to [%s] playlist..." % action)
        print(action_message)
        print("result: %s" % (action_status))
        print(' --- check access log for messages from \"StreamPublisher\"')


    # rimuovi applicazione
    def remove(self):
        
        result = self.vhost.machine.deleteDict("/v2/servers/_defaultServer_/vhosts/%s/applications/%s" % (self.vhost.name, self.name))
        
        action_status="na"
        action_success="na"
        action_message="no message..."
                
        if 'status' in result:
            action_status = result["status"]
        
        if 'wmsResponse' in result["data"]:
            if 'success' in result["data"]['wmsResponse']:
                if result["data"]['wmsResponse']['success'] == "true":
                    action_success="OK"
                else:
                    action_success="KO"
            if 'message' in result["data"]['wmsResponse']:
                action_message=result["data"]['wmsResponse']["message"]
        print("server: %s" % self.vhost.machine.name)
        print("   app: %s/%s\n" % (self.vhost.name, self.name))
        print(action_message)
        print("result: %s/%s" % (action_status, action_success))


        
    def reset_config_properties(self):
        self.__configuration = None
        self.__configurationAdv = None
        


class WztrTranscodertemplate():
    header_singular="Transcoder Template"
    header_plural="Transcoder Templates"

    def __init__(self, name, href):
        self.name = name
        self.href = href
        self.__configuration = None
        self.vhost=None

    def __str__(self):
        return "/%s/%s/transcoders/%s" % (self.vhost.machine.name, self.vhost.name, self.name)
    def __repr__(self):
        return "WztrTranscodertemplate: %s" % self.name

    @staticmethod
    def list_view_header():
        return "%-22s" % ("template name")
    def list_view(self):
        return "%-22s  /%s/%s/transcoders/%s" % (self.name,
            self.vhost.machine.name, self.vhost.name, self.name)
    def detail_view(self):
        return {
            "Transcoder template name": self.name
        }

    def configuration(self):
        # lazy-fetch transcoder template config
        if self.__configuration is None:
            self.__configuration={}

            result = self.vhost.machine.fetchDict(self.href)
            if result["status"] == "OK":
                if 'TranscoderTemplate' in result["data"].keys():
                    entry = result["data"]['TranscoderTemplate']
                
                    if 'Version' in entry.keys():
                        del entry['Version']
                    
                    # remove non active encodings
                    if 'Encodes' in entry.keys():
                        if isinstance(entry['Encodes'], dict) and 'TranscoderEncode' in entry['Encodes'].keys():
                            active_encodes=[]
                            for encode in entry['Encodes']['TranscoderEncode']:
                                if encode['Enable'] == 'true':
                                    active_overlays=[]
                                    # remove non-active overlays for each individual rendition
                                    if encode['Overlays'] is not None and 'TranscoderOverlayEncode' in encode['Overlays'].keys():
                                        for overlay in encode['Overlays']['TranscoderOverlayEncode']:
                                            if overlay['Enable'] == "true":
                                                active_overlays.append(overlay['Name'])
                                    encode['Overlays']=active_overlays
                                    active_encodes.append(encode)
                            entry['Encodes']['TranscoderEncode'] = active_encodes
                    # remove non-active overlays for all renditions ("Decoding Preset" tab)
                    if 'Overlays' in entry.keys():
                        if isinstance(entry['Overlays'], dict) and 'TranscoderOverlayDecode' in entry['Overlays'].keys():
                            active_overlays=[]
                            configured_overlays=entry['Overlays']['TranscoderOverlayDecode']
                            if not isinstance(configured_overlays, list):
                                configured_overlays = [ configured_overlays ]
                            for overlay in configured_overlays:
                                if overlay['Enable'] == "true":
                                    active_overlays.append(overlay)
                            entry['Overlays']['TranscoderOverlayDecode']=active_overlays
                            
                    self.__configuration = WztrTranscodertemplate.__clean_config_dict(entry)

        return self.__configuration

    # recursively remove irrelevant items from configuration dictionary
    def __clean_config_dict(config_dict, previousKey=None):
        if '@serverName' in config_dict.keys():
            del config_dict['@serverName']
        
        for key in config_dict.keys():
            if isinstance(config_dict[key], dict):
                cleanitem = WztrTranscodertemplate.__clean_config_dict(config_dict[key], key)
                config_dict[key] = cleanitem
        return config_dict




class WztrSmilFile():
    header_singular="SMIL file"
    header_plural="SMIL files"

    def __init__(self, name, href):
        self.name = name
        self.href = href
        self.__configuration = None
        self.application=None

    def __str__(self):
        return "/%s/%s/apps/%s/smil/%s" % (self.application.vhost.machine.name, self.application.vhost.name, self.application.name, self.name)
    def __repr__(self):
        return "WztrSmilFile: %s" % self.name

    @staticmethod
    def list_view_header():
        return "%-22s %s" % ("SMIL", "file name")
    def list_view(self):
        errormsg = ""
        if 'bad-data' in self.configuration():
            errormsg = "***** check XML file *****"
        return "%-22s %-55s %s" % (self.name, self.configuration()['FileLocation'], errormsg)
    def detail_view(self):
        return {
            "SMIL file name": self.name
        }

    def configuration(self):
        # lazy-fetch smil file config
        if self.__configuration is None:
            self.__configuration={}

            result = self.application.vhost.machine.fetchDict(self.href)
            
            if result["status"] == "OK":
                if 'SMILFile' in result["data"].keys():
                    entry = result["data"]['SMILFile']
                
                    if 'Version' in entry.keys():
                        del entry['Version']
                    
                    self.__configuration = WztrSmilFile.__clean_config_dict(entry)
            else:
                # aggiungi una proprietà per indicare che il file non può essere letto (bad XML probabilmente)
                self.__configuration["bad-data"] = True
            # aggiungi una proprietà con la directory in cui risiede il file
            content_dir = None
            name = "--nofile--"
            app_config_dict = self.application.configuration()
            if app_config_dict is not None:
                if 'StreamConfig' in app_config_dict.keys():
                    if 'StorageDir' in app_config_dict['StreamConfig'].keys():
                        content_dir = app_config_dict['StreamConfig']['StorageDir']
            if hasattr(self, 'name') and self.name != "":
                name = self.name
            
            if content_dir is None or content_dir == '':
                content_dir = "--no-dir-for-app-%s--" % self.application.name
            
            if content_dir[0] == '$':
                # rimuovi la variabile di configurazione con la root di Wowza
                content_dir_arr = content_dir.split("/")
                content_dir_arr.pop(0)
                content_dir = "/".join(content_dir_arr)
            if content_dir[-1] == '/':
                # rimuovi il trailing slash
                content_dir = content_dir[:-1]
            self.__configuration["FileLocation"] = "%s/%s.smil" % (content_dir, name)

        return self.__configuration

    # recursively remove irrelevant items from configuration dictionary
    def __clean_config_dict(config_dict, previousKey=None):
        if '@serverName' in config_dict.keys():
            del config_dict['@serverName']
        
        for key in config_dict.keys():
            if isinstance(config_dict[key], dict):
                cleanitem = WztrSmilFile.__clean_config_dict(config_dict[key], key)
                config_dict[key] = cleanitem
        return config_dict



# class used to create a temporary list of mediacache entries
# using a class in order to avail of the code to render lists
class WztrMediacacheItem():
    header_singular="Mediacache item"
    header_plural="Mediacache items"
    
    def __init__(self, name, length):
        # il nome dell'emento cachato viene memorizzato in forma URL encoded
        self.name=quote_plus(name)
        self.length_mb = round(int(length)/1048576)
        self.vhost=None

    def __str__(self):
        return "/%s/%s/%s" % (self.vhost.machine.name, self.vhost.name, self.name)
    def __repr__(self):
        return "WztrMediacacheItem: %s" % unquote(self.name)
    
    def flush(self):
        result = self.vhost.machine.putDict("/v2/servers/_defaultServer_/vhosts/%s/mediacache/stores/actions/flushAndForceItemFromCache?filename=%s" % (self.vhost.name, self.name))
        
        action_success="na"
        action_message="no message..."
                
        if 'wmsResponse' in result["data"]:
            wms_response = result["data"]["wmsResponse"]
        
            if 'message' in wms_response:
                action_message = wms_response["message"]
            
            if 'success' in wms_response:
                if wms_response["success"] == "true":
                    action_success="OK"
                else:
                    action_success="!!!KO!!!"
        
        print(action_message)
        print("result: %s" % (action_success))
        


# class used to create a temporary list of incomingstream entries
# using a class in order to avail of the code to render lists
class WztrIncomingStream():
    header_singular="Incoming stream"
    header_plural="Incoming streams"
    
    def __init__(self, name, instance, source, recording, manager, publishedtovod, connected):
        self.name=name
        self.instancename=instance
        self.source = source
        self.recording = recording
        self.manager = manager
        self.publishedtovod = publishedtovod
        self.connected = connected
        self.application=None

    def __str__(self):
        return "/%s/%s/%s" % (str(self.application), self.instancename, self.name)
    def __repr__(self):
        return "WztrIncomingStream: %s" % self.name
    
    @staticmethod
    def list_view_header():
        return "%-40s %-11s %-28s %s" % ("Application", "Instance", "Name", "Source")
    def list_view(self):
        return "%-40s %-11s %-28s %s" % (str(self.application), self.instancename, self.name, self.source)
    def detail_view(self):
        return {
            "Name": self.name,
            "Application": str(self.application),
            "Source": self.source,
            "Is recording": self.recording,
            "Is Stream Manager": self.manager,
            "Published to VOD": self.publishedtovod,
            "Is connected": self.connected
        }



class WztrVhost():
    header_singular="VHost"
    header_plural="VHosts"

    def __init__(self, name, href, connectingIPAddress, connectingPort, connectingSSLEnable=False):
        self.name = name
        self.href = href
        self.connectingPort = connectingPort
        self.connectingIPAddress = connectingIPAddress
        if connectingSSLEnable == "true":
            self.connectingSSLEnable = True
        else:
            self.connectingSSLEnable = False
        
        self.__configuration = None
        self.__mediacachecontent = None
        self.__configurationAdv = None
        self.__applications = None
        self.__transcoderTemplates = None
        self.__smilfiles = None
        self.machine=None
    
    def __str__(self):
        return "/%s/%s" % (self.machine.name, self.name)
    def __repr__(self):
        return "WztrVhost: %s" % self.name

    @staticmethod
    def list_view_header():
        return "VHost name"
    def list_view(self):
        return str(self)
    def detail_view(self):
        return {
            "Machine": str(self.machine),
            "Addr/Port": "%s/%s" % (self.connectingIPAddress, self.connectingPort),
            "SSL": "YES" if self.connectingSSLEnable else "NO",
        }
    
    def mediacachecontent(self):
        # no lazy-fetch for mediacache
        # always return fresh data
        # content is cached in self.__mediacachecontent anyway, just in case
        self.__mediacachecontent={}

        result = self.machine.fetchDict("/v2/servers/_defaultServer_/vhosts/%s/mediacache/stores" % self.name)

        if result["status"] == "OK":
            if 'MediaCacheStoreList' in result["data"].keys():
                if 'MediaCacheItemList' in result["data"]["MediaCacheStoreList"].keys():
                    items = result["data"]["MediaCacheStoreList"]["MediaCacheItemList"]
                    if not isinstance(items, list):
                        items = [ items ]
                    for item in items:
                        newmediacacheitem = WztrMediacacheItem(item['ItemName'], item['ItemLength'])
                        newmediacacheitem.vhost = self

                        self.__mediacachecontent[newmediacacheitem.name] = newmediacacheitem
                                

        return self.__mediacachecontent

    def incomingstreams(self):
        # always return fresh data
        item_list=[]
        #for app in self.applications().values():
        for app in self.machine.activeapps():
            if app.vhost == self:
                item_list += app.incomingstreams().values()
        
        return item_list

    

    def configuration(self):
        # lazy-fetch vhost config
        if self.__configuration is None:
            self.__configuration={}

            result = self.machine.fetchDict(self.href)
            if result["status"] == "OK":
                if 'VHost' in result["data"].keys():
                    # result["data"]['VHost'] is a list that contains one element, using "pop()" to get it
                    entry = result["data"]['VHost']
                
                    if 'Version' in entry.keys():
                        del entry['Version']
                    if 'HostPorts' in entry.keys() and 'HostPort' in entry['HostPorts'].keys():
                        for en in entry['HostPorts']['HostPort']:
                            if 'SSLKeyStorePassword' in en.keys():
                                en['SSLKeyStorePassword'] = "******"
                
                    self.__configuration = entry
        return self.__configuration
    
    # in wowza APIs, VHost Properties are referred to as vhost/advanced
    def configurationAdvanced(self):
        # lazy-fetch application advanced config
        if self.__configurationAdv is None:
            self.__configurationAdv={}
            
            result = self.machine.fetchDict(self.href + "/adv")
            if result["status"] == "OK":
                if 'VHostAdv' in result["data"].keys():
                    if 'AdvancedSettings' in result["data"]['VHostAdv'].keys():
                        advSettings = result["data"]['VHostAdv']['AdvancedSettings']
                        if 'AdvancedSetting' in advSettings.keys():
                            # show only active properties
                            properties=[]
                            for prop in advSettings['AdvancedSetting']:
                                if prop['@enabled'] == 'true':
                                    shortprop = {
                                        'Name': prop['Name'],
                                        'Type': prop['Type'],
                                        'Value': prop['Value'],
                                        'SectionName': "",
                                        'Section': ""
                                    
                                    }
                                    if 'Section' in prop.keys():
                                        shortprop['Section'] = prop['Section']
                                    if 'SectionName' in prop.keys():
                                        shortprop['SectionName'] = prop['SectionName']
                            
                                    properties.append(shortprop)
                            
                            self.__configurationAdv=properties
        return self.__configurationAdv



    def applications(self):
        # lazy-fetch applications
        if self.__applications is None:
            self.__applications={}
            result = self.machine.fetchDict("/v2/servers/_defaultServer_/vhosts/%s/applications" % self.name)

            if result["status"] == "OK":
                if 'Applications' in result["data"].keys():
                    entry = result["data"]['Applications']
                    if 'Application' in entry.keys():
                        items = entry['Application']
                        for item in items:
                            newapp = WztrApplication(item['@id'], item['@href'], item['AppType'], item['DVREnabled'], item['DRMEnabled'], item['TranscoderEnabled'], item['StreamTargetsEnabled'])
                            newapp.vhost = self
                    
                            self.__applications[newapp.name] = newapp

        return self.__applications
        
    def transcodertemplates(self):
        # lazy-fetch transcoder templates
        if self.__transcoderTemplates is None:
            self.__transcoderTemplates={}
            result = self.machine.fetchDict("/v2/servers/_defaultServer_/vhosts/%s/transcoder/templates" % self.name)

            if result["status"] == "OK":
                if 'TranscoderTemplates' in result["data"].keys():
                    entry = result["data"]['TranscoderTemplates']
                    if 'Template' in entry.keys():
                        items = entry['Template']
                        for item in items:
                            newtranstempl = WztrTranscodertemplate(item['@id'], item['@href'])
                            newtranstempl.vhost = self
                
                            self.__transcoderTemplates[newtranstempl.name] = newtranstempl
                
        return self.__transcoderTemplates

    def smilfiles(self):
        # lazy-fetch smil files for each application so that all content dirs are navigated
        if self.__smilfiles is None:
            self.__smilfiles={}
            
            # cycle thorugh apps
            for app_key in self.applications().keys():
                cur_smil_list = self.applications()[app_key].smilfiles()
                # cycle through SMIL objects
                for smil_key in cur_smil_list.keys():
                    smil_obj = cur_smil_list[smil_key]
                    # add SMIL objs, unique by FileLocation
                    self.__smilfiles[smil_obj.configuration()['FileLocation']] = smil_obj
                
        return self.__smilfiles

# class used to create a temporary list of licenses and associated servers
# using a class in order to avail of the code to render lists
class WztrLicense():
    header_singular="License"
    header_plural="Licenses"
    
    def __init__(self, key):
        self.key=key
        self.servers=[]

    def __str__(self):
        return self.key
    def __repr__(self):
        return "WztrLicense: %s" % self.key
    
    @staticmethod
    def list_view_header():
        return " %-36s  servers" % ("License key")
    def list_view(self):
        return " %-36s [%s]" % (self.key, ", ".join(self.servers))
    def detail_view(self):
        return {
            "License key": self.key,
            "Servers": self.servers(),
        }
    
    def add_server(self, machine):
        self.servers.append(machine.name)


    
class WztrMachine():
    header_singular="Machine"
    header_plural="Machines"
    
    def __init__(self, name, address, user, pw, port=None):
        self.name=name
        self.address=address
        self.user=user
        self.pw=pw
        self.use_https=False
        self.auth = "basic"
        self.__vhosts = None
        self.__version = None
        self.__licenses = None
        
        if port is not None:
            self.port=port
        else:
            self.port="8087"

    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrMachine: %s" % self.name

    @staticmethod
    def list_view_header():
        return " %-10s %-17s  %s" % ("Name", " address", "Version")
    def list_view(self):
        return " %-10s %-17s %s" % (self.name, "(" + self.address + ")", self.version())
    def detail_view(self):
        return {
            "API Address/port": "%s/%s" % (self.address, self.port),
            "Version": self.version(),
            "HTTPS": "YES" if self.use_https else "NO",
            "Credentials": {
                "user": self.user,
                "pw": "*******"
            },
            "Licenses": self.licenses()
        }
    
    # esegui una HTTP GET
    def fetch(self, url, tcp_port=None):
        return self.__do_api_call(url, "GET", tcp_port)

    def fetchDict(self, url, tcp_port=None):
        return self.__do_api_call_dict(url, "GET", tcp_port)
        
        #response = self.fetch(url)
        
        #if response["status"] == "OK":
        #    try:
        #        response["data"] = xmltodict.parse(
        #            response["data"],
        #            dict_constructor=dict,
        #            xml_attribs=True,
        #            force_list=('VHosts', 'TranscoderEncode', 'TranscoderOverlayEncode')
        #        )
        #    except:
        #        response["status"] = "KO"
        #        response["data"] = "invalid XML reply"
        #        
        #return response

    # esegui una HTTP PUT
    def put(self, url, tcp_port=None):
        return self.__do_api_call(url, "PUT", tcp_port)
    def putDict(self, url, tcp_port=None):
        return self.__do_api_call_dict(url, "PUT", tcp_port)

    # esegui una HTTP DELETE
    def delete(self, url, tcp_port=None):
        return self.__do_api_call(url, "DELETE", tcp_port)
    def deleteDict(self, url, tcp_port=None):
        return self.__do_api_call_dict(url, "DELETE", tcp_port)


    def __do_api_call_dict(self, url, method, tcp_port=None):
        response = self.__do_api_call(url, method, tcp_port)
        
        if response["status"] == "OK":
            try:
                response["data"] = xmltodict.parse(
                    response["data"],
                    dict_constructor=dict,
                    xml_attribs=True,
                    force_list=('VHosts', 'TranscoderEncode', 'TranscoderOverlayEncode')
                )
            except:
                response["status"] = "KO"
                response["data"] = "invalid XML reply"
                
        return response

    def __do_api_call(self, url, method, tcp_port=None):
        data=""
        status="OK"
        try:
            base_url="http://"
            if self.use_https:
                base_url="https://"
            
            base_url += self.address
            
            if tcp_port is None:
                tcp_port=self.port
            
            url = "%s:%s%s" % (base_url, tcp_port, url) 
            
            if self.auth == "basic":
                auth=httpx.BasicAuth(
                    self.user, self.pw
                )
            else:
                # prima della version 4.8.8.01
                auth=httpx.DigestAuth(
                    self.user, self.pw
                )
            
            response = None
            if method == "GET":
                response = httpx.get(
                    url,
                    auth=auth,
                    timeout=httpx.Timeout(timeout=3)
                )
            elif method == "PUT":
                response = httpx.put(
                    url,
                    auth=auth,
                    timeout=httpx.Timeout(timeout=3)
                )
            elif method == "DELETE":
                response = httpx.delete(
                    url,
                    auth=auth,
                    timeout=httpx.Timeout(timeout=3)
                )
            
            if int(response.status_code) >= 200 and int(response.status_code) <= 299:
                data = response.text
            else:
                data = 'HTTP error %s' % response.status_code
                status="KO"
                
        except NetworkError:
            data='timeout %s %s on machine %s' % (method, url, self)
            status="KO"
        except Exception as e:
            data='error %s %s on machine %s' % (method, url, self)
            status="KO"
        
        return {"data": data, "status": status}
        
    
    
    def reset_cache(self):
        self.__vhosts = None
        self.__version = None
        self.__licenses = None
    
    def vhosts(self):
        # lazy-fetch vhosts
        if self.__vhosts is None:
            self.__vhosts={}
            result = self.fetchDict("/v2/servers/_defaultServer_/vhosts")
            if result["status"] == "OK":
                if 'VHosts' in result["data"].keys():
                    for vhost_entry in result["data"]['VHosts']:
                        vhost = vhost_entry['Vhost']
                        newvh = WztrVhost(vhost['@id'], vhost['@href'], vhost['@connectingIPAddress'], vhost['@connectingPort'], vhost['@connectingSSLEnable'])
                        newvh.machine = self
                    
                        self.__vhosts[newvh.name] = newvh

        return self.__vhosts

    def version(self):
        # lazy-fetch version
        if self.__version is None:
            self.__version = "*** No connection ***"
            result = self.fetch("")
            if result["status"] == "OK":
                self.__version = (result["data"])
        
        return self.__version



    def licenses(self):
        # lazy-fetch machine licenses
        if self.__licenses is None:
            self.__licenses = {}
            result = self.fetchDict("/v2/servers/_defaultServer_/licenses")
            if result["status"] == "OK":
                if 'ServerLicenses' in result["data"].keys():
                    entry = result["data"]['ServerLicenses']
                
                    if 'Licenses' in entry.keys():
                        entry = entry['Licenses']
                        if 'string' in entry.keys():
                            index=0
                            if isinstance(entry['string'], list):
                                for lic in entry['string']:
                                    self.__licenses[index] = lic
                                    index += 1
                            else:
                                self.__licenses[index] = entry['string']

        return self.__licenses


    def connectioncounts(self, appsonly=False):
        # no cache
        connectioncounts={}
        result = self.fetchDict("/connectioncounts", "8086")
        if result["status"] == "OK":
            if 'WowzaStreamingEngine' in result["data"].keys():
                connectioncounts = {
                    'ConnectionsCurrent': result["data"]['WowzaStreamingEngine']['ConnectionsCurrent'],
                    'MessagesInBytesRate': result["data"]['WowzaStreamingEngine']['MessagesInBytesRate'],
                    'MessagesOutBytesRate': result["data"]['WowzaStreamingEngine']['MessagesOutBytesRate'],
                    'vhosts': []
                }
                if 'VHost' in result["data"]['WowzaStreamingEngine'].keys():
                    vhost_list=result["data"]['WowzaStreamingEngine']['VHost']
                    if not isinstance(vhost_list, list):
                        vhost_list=[vhost_list]
                    for vhost_entry in vhost_list:
                        vhost = {
                            "Name": vhost_entry['Name'],
                            "applications": []
                        }
                        if 'Application' in vhost_entry.keys():
                            app_list=vhost_entry['Application']
                            if not isinstance(app_list, list):
                                app_list=[app_list]
                            for app_entry in app_list:
                                application = {
                                    "Name": app_entry['Name'],
                                    "ConnectionsCurrent": app_entry['ConnectionsCurrent'],
                                    "MessagesInBytesRate": app_entry['MessagesInBytesRate'],
                                    "MessagesOutBytesRate": app_entry['MessagesOutBytesRate'],
                                    "instances": []
                                }
                                if not appsonly:
                                    if 'ApplicationInstance' in app_entry.keys():
                                        inst_list=app_entry['ApplicationInstance']
                                        if not isinstance(inst_list, list):
                                            inst_list=[inst_list]
                                        for inst_entry in inst_list:
                                            instance = {
                                                "Name": inst_entry['Name'],
                                                "ConnectionsCurrent": inst_entry['ConnectionsCurrent'],
                                                "MessagesInBytesRate": inst_entry['MessagesInBytesRate'],
                                                "MessagesOutBytesRate": inst_entry['MessagesOutBytesRate'],
                                                "streams": []
                                            }
                                            if 'Stream' in inst_entry.keys():
                                                stream_list=inst_entry['Stream']
                                                if not isinstance(stream_list, list):
                                                    stream_list=[stream_list]
                                                for stream_entry in stream_list:
                                                    stream = {
                                                        'Name': stream_entry['Name'],
                                                        'SessionsTotal': stream_entry['SessionsTotal']
                                                    }
                                                    instance['streams'].append(stream)
                                            application['instances'].append(instance)
                                vhost['applications'].append(application)
                        connectioncounts['vhosts'].append(vhost)
        return connectioncounts

    def activeapps(self):
        activeapps=[]
        vhost_objs=self.vhosts()
        for vhost in self.connectioncounts(True)['vhosts']:
            if vhost['Name'] in vhost_objs.keys():
                app_objs=vhost_objs[vhost['Name']].applications()
                for app in vhost['applications']:
                    if app['Name'] in app_objs.keys():
                        activeapps.append(app_objs[app['Name']])
                    else:
                        print("**Warning: no Application %s, refresh needed" % app['Name'])
            else:
                print("**Warning: no VHost %s, refresh needed" % vhost['Name'])
        
        return activeapps

    def incomingstreams(self):
        # always return fresh data
        item_list=[]
        for app in self.activeapps():
            item_list += app.incomingstreams().values()
        
        return item_list


from cmd2 import Cmd
import json, sys

_CONFIGFILE="config.json"





class WztrPrompt(Cmd):
    
    def __init__(self):
        # set terminal title
        print('\33]0;Wowzator\a', end='', flush=True)
        
        print("initializing...")
        
        #Cmd.__init__(self)
        super().__init__()
        
        # To remove built-in commands entirely, delete
        # the "do_*" function from the cmd2.Cmd class
        del Cmd.do_run_pyscript
        del Cmd.do_run_script
        del Cmd.do_edit
        del Cmd.do_set
        del Cmd.do_shortcuts
        del Cmd.do_shell
        self.hidden_commands.append('exit')
        self.hidden_commands.append('q')
        self.hidden_commands.append('alias')
        self.hidden_commands.append('macro')
        self.hidden_commands.append('EOF')
        
        self.prompt = 'wowzator> '
        self.intro = "\nWowzator: a simple Wowza Configuration Manager by Top-IX (streaming.top-ix.org)\n\t- \"help\" or \"?\" for info about commands\n\t- TAB to autocomplete\n"
        
        # secure mode, disable piping and redirection of commands ("|" and ">")
        #self.allow_redirection = False
        
        self.machines = {}
        self.relationsLicenseServer = []
        secure_mode=True
        
        try:
            with open(_CONFIGFILE) as json_file:
                try:
                    json_object = json.load(json_file)
                    try:
                        machines_config = json_object["servers"]
        
                        for machine_config in machines_config:
                            machine=WztrMachine(name=machine_config["name"], address=machine_config["address"], user=machine_config["user"], pw=machine_config["pw"])
                            if "auth" in machine_config.keys():
                                machine.auth = machine_config["auth"]
                        
                            self.machines[machine.name]=machine
                    except Exception as e:
                        print("Cannot find attribute \"servers\" in JSON %s" % _CONFIGFILE)
                        sys.exit(-1)
                    try:
                        secure_mode = json_object["secure_mode"]
                        if secure_mode == "true":
                            secure_mode=True
                        else:
                            secure_mode=False
                    except Exception as e:
                        print("Cannot find attribute \"secure_mode\" in JSON %s" % _CONFIGFILE)
                        sys.exit(-1)
                except Exception as e:
                    print(e)
                    print("Bad JSON in %s" % _CONFIGFILE)
                    sys.exit(-1)
        
        except Exception as e:
            print(e)
            print("Cannot open %s" % _CONFIGFILE)
            sys.exit(-1)



        if secure_mode:
            self.allow_redirection = False
            self.intro = self.intro + "Secure mode ON, disable for redirection functionalities (see \"secure_mode\" in config)\n"
        else:
            self.allow_redirection = True
            self.intro = self.intro + "\t- use \"|\" to pipe output to shell commands, eg. \"ls all/apps | grep myapp\" (see \"secure_mode\" in config)\n"
            self.intro = self.intro + "\t- use \">\" to redirect output to file, eg. \"ls all/apps > applist.txt\" (see \"secure_mode\" in config)\n"
            
        
    
    
    
    
    # Syntax tree for the list commeand
    syntaxtree_ls = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": [
                        {
                            "keyword": "apps",
                            "keyword_type": "predicate",
                            "syntaxtree": [
                                {
                                    "keyword": "$APPLICATION",
                                    "keyword_type": "object",
                                    "syntaxtree": [
                                        {
                                            "keyword": "configuration",
                                            "keyword_type": "predicate",
                                            "syntaxtree": [
                                                {
                                                    "keyword": "properties",
                                                    "keyword_type": "predicate",
                                                    "syntaxtree": []
                                                }
                                            ]
                                        },
                                        {
                                            "keyword": "details",
                                            "keyword_type": "predicate",
                                            "syntaxtree": []
                                        },
                                        {
                                            "keyword": "smil",
                                            "keyword_type": "predicate",
                                            "syntaxtree": [
                                                {
                                                    "keyword": "$SMILFILES",
                                                    "keyword_type": "object",
                                                    "syntaxtree": [
                                                        {
                                                            "keyword": "configuration",
                                                            "keyword_type": "predicate",
                                                            "syntaxtree": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "keyword": "configuration",
                            "keyword_type": "predicate",
                            "syntaxtree": [
                                {
                                    "keyword": "properties",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                }
                            ]
                        },
                        {
                            "keyword": "details",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        },
                        {
                            "keyword": "transcoders",
                            "keyword_type": "predicate",
                            "syntaxtree": [
                                {
                                    "keyword": "$TRANSCODERTEMPLATE",
                                    "keyword_type": "object",
                                    "syntaxtree": [
                                        {
                                            "keyword": "configuration",
                                            "keyword_type": "predicate",
                                            "syntaxtree": []
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "keyword": "smil",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        },
                        
                    ]
                },
                {
                    "keyword": "details",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                }
            ]
        },
        {
            "keyword": "$ALL_MACHINES",
            "keyword_type": "multi_object",
            "syntaxtree": [
                {
                    "keyword": "apps",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                },
                {
                    "keyword": "licenses",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                }
            ]
        }
    ]


    # Syntax tree for the diff commeand (first argument)
    syntaxtree_diff = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": [
                        {
                            "keyword": "apps",
                            "keyword_type": "predicate",
                            "syntaxtree": [
                                {
                                    "keyword": "$APPLICATION",
                                    "keyword_type": "object",
                                    "syntaxtree": [
                                        {
                                            "keyword": "smil",
                                            "keyword_type": "predicate",
                                            "syntaxtree": [
                                                {
                                                    "keyword": "$SMILFILES",
                                                    "keyword_type": "object",
                                                    "syntaxtree": []
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "keyword": "configuration",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        },
                        {
                            "keyword": "transcoders",
                            "keyword_type": "predicate",
                            "syntaxtree": [
                                {
                                    "keyword": "$TRANSCODERTEMPLATE",
                                    "keyword_type": "object",
                                    "syntaxtree": [
                                        {
                                            "keyword": "config",
                                            "keyword_type": "predicate",
                                            "syntaxtree": []
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "keyword": "smil",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        },
                        
                    ]
                } 
            ]
        },
    ]

    
    # Syntax tree for the mediacache flush command
    syntaxtree_mediacache_flush = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": [
                        {
                            "keyword": "all",
                            "keyword_type": "predicate",
                            "syntaxtree": []
                        },
                        {
                            "keyword": "$MEDIACACHEITEM",
                            "keyword_type": "object",
                            "syntaxtree": []
                        }
                    ]
                } 
            ]
        },
    ]

    # Syntax tree for the mediacache list command
    syntaxtree_mediacache_ls = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": []
                } 
            ]
        },
        {
            "keyword": "$ALL_MACHINES",
            "keyword_type": "multi_object",
            "syntaxtree": []
        }
        
    ]
    
    syntaxtree_status_incomingstreams = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": []
        },
    ]

    # comando per gestire le playlist del modulo StreamPublisher
    syntaxtree_playlist = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": [
                        {
                            "keyword": "apps",
                            "keyword_type": "predicate",
                            "syntaxtree": [
                                {
                                    "keyword": "$APPLICATION",
                                    "keyword_type": "object",
                                    "syntaxtree": []
                                }
                            ]
                        }
                    ]
                } 
            ]
        },
    ]

    # comando remove
    syntaxtree_remove = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "$VHOST",
                    "keyword_type": "object",
                    "syntaxtree": [
                        {
                            "keyword": "apps",
                            "keyword_type": "predicate",
                            "syntaxtree": [
                                {
                                    "keyword": "$APPLICATION",
                                    "keyword_type": "object",
                                    "syntaxtree": []
                                }
                            ]
                        }
                    ]
                } 
            ]
        },
    ]

    
    tableformat_application = {
                            "Module": [
                                {
                                    "key": "Order",
                                    "title": "ord",
                                    "length": "3"
                                },
                                {
                                    "key": "Name",
                                    "length": "24"
                                },
                                {
                                    "key": "Description",
                                    "length": "22"
                                },
                                {
                                    "key": "Class"
                                }
                            ]
                        }
    tableformat_transcoder = {
                            "TranscoderEncode": [
                                {
                                    "key": "Name",
                                    "length": "6"
                                },
                                {
                                    "key": "Enable",
                                    "title": "Enab",
                                    "length": "5"
                                },
                                {
                                    "key": "StreamName",
                                    "length": "30"
                                },
                                {
                                    "key": "VideoCodec",
                                    "title": "video",
                                    "length": "8"
                                },
                                {
                                    "key": "GPUID",
                                    "title": "GPU",
                                    "length": "3"
                                },
                                {
                                    "key": "VideoBitrate",
                                    "title": "vid.br",
                                    "length": "21"
                                },
                                {
                                    "key": "FollowSource",
                                    "title": "F.src",
                                    "length": "5"
                                },
                                {
                                    "key": "Interval",
                                    "title": "int",
                                    "length": "3"
                                },
                                {
                                    "key": "Width",
                                    "title": "wid.",
                                    "length": "4"
                                },
                                {
                                    "key": "Height",
                                    "title": "hei.",
                                    "length": "4"
                                },
                                {
                                    "key": "AudioCodec",
                                    "title": "audio",
                                    "length": "5"
                                },
                                {
                                    "key": "AudioBitrate",
                                    "title": "aud.br",
                                    "length": "6"
                                },
                                {
                                    "key": "Overlays",
                                }
                            ],
                            "com.wowza.wms.rest.vhosts.transcoder.TranscoderMemberConfig": [
                                {
                                    "key": "MemberName",
                                    "length": "10"
                                },
                                {
                                    "key": "EncodeName",
                                    "length": "10"
                                },
                                {
                                    "key": "WowzaVideoOnly",
                                    "length": "14"
                                },
                                {
                                    "key": "WowzaAudioOnly",
                                    "length": "14"
                                }
                            ]
                        }
    tableformat_smil = {
                            "SMILStream": [
                                {
                                    "key": "Index",
                                    "title": "id",
                                    "length": "2"
                                },
                                {
                                    "key": "Type",
                                    "length": "6"
                                },
                                {
                                    "key": "Src",
                                    "length": "30"
                                },
                                {
                                    "key": "SystemLanguage",
                                    "title": "Lang",
                                    "length": "6"
                                },
                                {
                                    "key": "SystemBitrate",
                                    "title": "Sys br",
                                    "length": "7"
                                },
                                {
                                    "key": "Width",
                                    "title": "wdt",
                                    "length": "5"
                                },
                                {
                                    "key": "Height",
                                    "title": "hght",
                                    "length": "5"
                                },
                                {
                                    "key": "VideoBitrate",
                                    "title": "V.br",
                                    "length": "7"
                                },
                                {
                                    "key": "VideoCodecId",
                                    "title": "V.cod",
                                    "length": "12"
                                },
                                {
                                    "key": "AudioBitrate",
                                    "title": "A.br",
                                    "length": "5"
                                },
                                {
                                    "key": "AudioCodecId",
                                    "title": "A.cod",
                                    "length": "12"
                                }
                            ]
                        }
                        
                        
    def do_exit(self, inp):
        print('Bye')
        return True
    
    do_EOF=do_exit
    do_q=do_exit

    # return an array of objects or a single instance depending on what the path points to
    def __get_obj_by_path(self, syntax_tree, path):
        self.command_object = None
        self.command_objects = None
        self.command_predicate = None
        self.command_error = None
        
        completion = []
        
        
        path_arr = path.split("/")
        
        removed_trailing_slash = False
        removed_leading_slash = False
        # set to True by default to deal with empty path
        # if path is provided it will be immediately set to False when path is parsed
        keyword_matched = True
        
        # remove last and first elements of path if empty
        if len(path_arr) > 0 and path_arr[-1] == "":
            path_arr.pop()
            removed_trailing_slash = True
        if len(path_arr) > 0 and path_arr[0] == "":
            path_arr.pop(0)
            removed_leading_slash = True
        
        expanded_syntax_tree = self.__expand_keywords(syntax_tree)
        cur_path_pos = 0
        for cur_path_el in path_arr:
            
            keyword_matched = False
            for syntax_el in expanded_syntax_tree:
                if cur_path_el == syntax_el["keyword"]:

                    if syntax_el["keyword_type"] == "object":
                        self.command_object = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "multi_object":
                        self.command_objects = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "predicate":
                        self.command_predicate = syntax_el["keyword"]

                    # move down syntax tree
                    expanded_syntax_tree = self.__expand_keywords(syntax_el["syntaxtree"])
                    keyword_matched = True
            
            if not keyword_matched:
                self.command_error = "%s: keyword not recognized" % cur_path_el
                cur_path = "/".join(path_arr[:cur_path_pos])
                if cur_path != "":
                    cur_path += "/"
                if removed_leading_slash:
                    cur_path = "/" + cur_path
            
                for syntax_el in expanded_syntax_tree:
                    completion_item = cur_path + syntax_el["keyword"]
                    completion.append( completion_item )
                    # if len(syntax_el["syntaxtree"]) > 0:
                    #    completion.append( cur_path + syntax_el["keyword"] +"/" )

                break
            
                
            cur_path_pos += 1
                
        if keyword_matched:
            cur_path = "/".join(path_arr[:cur_path_pos])
            if cur_path != "":
                cur_path += "/"
            if removed_leading_slash:
                cur_path = "/" + cur_path
        
            for syntax_el in expanded_syntax_tree:
                completion_item = cur_path + syntax_el["keyword"]
                completion.append( completion_item )
                # if len(syntax_el["syntaxtree"]) > 0:
                #    completion.append( cur_path + syntax_el["keyword"] +"/" )
            
        
        return {
            "object": self.command_object,
            "objects": self.command_objects,
            "predicate": self.command_predicate,
            "error": self.command_error,
            "completion": completion
        }

    
    # expand macro keywords in first level of syntax tree
    def __expand_keywords(self, syntax_tree):
        expanded_syntax_tree = []
        for syntax_el in syntax_tree:
            kw = syntax_el["keyword"]
            if kw[0] == "$":
                expanded_dict = self.__expand_keyword_macro(kw)
                for expanded_kw in expanded_dict.keys():
                    exp_syntax_el = {
                        "keyword": expanded_kw,
                        "keyword_type": syntax_el["keyword_type"],
                        "syntaxtree": syntax_el["syntaxtree"],
                        "data": expanded_dict[expanded_kw]
                    }
                    expanded_syntax_tree.append(exp_syntax_el)
            else:
                expanded_syntax_tree.append(syntax_el)
        
        return expanded_syntax_tree
    
    
    
    
    # expand individual macro
    def __expand_keyword_macro(self, keyword):
        expanded_dict = {}
        if keyword == "$MACHINE":
            expanded_dict = self.machines
        elif keyword == "$ALL_MACHINES":
            expanded_dict["all"]=self.machines.values()
        elif keyword == "$VHOST":
            expanded_dict = self.command_object.vhosts()
        elif keyword == "$APPLICATION":
            expanded_dict = self.command_object.applications()
        elif keyword == "$TRANSCODERTEMPLATE":
            expanded_dict = self.command_object.transcodertemplates()
        elif keyword == "$SMILFILES":
            expanded_dict = self.command_object.smilfiles()
        elif keyword == "$MEDIACACHEITEM":
            expanded_dict = self.command_object.mediacachecontent()
            
            # in questo caso il nome del mediacache item contiene slashes
            # lo espando con tutti i nomi "intemedi"
            #expanded_dict={}
            #mediacontent_dict = self.command_object.mediacachecontent()
            #for item_path in mediacontent_dict.keys():
            #    item_path_ar = item_path.split("/")
            #    for i in range(1, len(item_path_ar) + 1):
            #        partial_key = item_path_ar[i]
            #        expanded_dict[partial_key]={}
            #        expanded_dict[partial_key] = None

        return expanded_dict


    def do_ls(self, inp):
        print()
        
        self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, inp)
        
        if self.command_error is None:
            if self.command_object is None:
                if self.command_objects is None:
                    self.__ls_objects(self.machines.values(), self.command_predicate)
                else:
                    self.__ls_objects(self.command_objects, self.command_predicate)
            else:
                self.__ls_object(self.command_object, self.command_predicate)
        else:
            print("** Error: %s" % self.command_error)

    def __ls_objects(self, object_list, predicate=None):
        object_list = list(object_list)
        if len(object_list) > 0:
            if predicate is None:
                print("%s" % object_list[0].header_plural)
                print("%s" % object_list[0].list_view_header())
                for cur_obj in object_list:
                    print(" %s" % cur_obj.list_view())
            else:
                if predicate == 'apps':
                    # list all applications
                    item_list = []
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            for vhost in machine.vhosts().values():
                                item_list += vhost.applications().values()
                    self.__ls_objects(item_list)
                elif predicate == 'licenses':
                    # list all licences
                    item_dict = {}
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            for licensekey in machine.licenses().values():
                                if licensekey not in item_dict.keys():
                                    item_dict[licensekey] = WztrLicense(licensekey)
                                item_dict[licensekey].add_server(machine)
                    self.__ls_objects(item_dict.values())
                elif predicate == 'mediacache':
                    # list content of mediacache sources
                    item_list = []
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            for vhost in machine.vhosts().values():
                                item_list += vhost.mediacachecontent().values()
                    self.__ls_objects(item_list)
                elif predicate == 'incomingstreams':
                    # list incoming streams
                    item_list = []
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            item_list += machine.incomingstreams()
                    self.__ls_objects(item_list)
                    
        else:
            print("empty list...")
        print()
        
    def __ls_object(self, object_instance, predicate=None):
        if predicate is None:
            if isinstance(object_instance, WztrMachine):
                # machine specified, list vhosts
                self.__ls_objects(object_instance.vhosts().values())
        else:
            if predicate == "details":
                print("%s: %s" % (object_instance.header_singular, object_instance))
                print( self.dict_formatter( object_instance.detail_view() ) )
            elif predicate == "smil":
                if isinstance(object_instance, WztrApplication):
                    # SMIL files for application
                    self.__ls_objects(object_instance.smilfiles().values())
                elif isinstance(object_instance, WztrVhost):
                    # SMIL files for all apps in VHost
                    self.__ls_objects(object_instance.smilfiles().values())
                elif isinstance(object_instance, WztrSmilFile):
                    # SMIL file specified withoutany further predicate
                    print("/configuration\n\n")
                else:
                    print("WARNING: no \"%s\" keyword defined for object of type %s" % (predicate, type(object_instance)))
                
            elif predicate == "configuration":
                if isinstance(object_instance, WztrApplication) or \
                   isinstance(object_instance, WztrTranscodertemplate) or \
                   isinstance(object_instance, WztrVhost) or \
                   isinstance(object_instance, WztrSmilFile):
                    table_attr = None
                    # force modules to be rendered as a table
                    if isinstance(object_instance, WztrApplication):
                        table_attr = WztrPrompt.tableformat_application
                    elif isinstance(object_instance, WztrTranscodertemplate):
                        table_attr = WztrPrompt.tableformat_transcoder
                    elif isinstance(object_instance, WztrSmilFile):
                        table_attr = WztrPrompt.tableformat_smil
                    
                    # show config
                    print(self.dict_formatter(object_instance.configuration(), 0, table_attr))
                else:
                    print("WARNING: no \"%s\" keyword defined for object of type %s" % (predicate, type(object_instance)))
            elif predicate == "properties":
                if isinstance(object_instance, WztrApplication) or isinstance(object_instance, WztrVhost):
                    # properties (adv config) of app
                    fields = [
                        {
                            "key": "Name",
                            "length": "36"
                        },
                        {
                            "key": "Type",
                            "length": "8"
                        },
                        {
                            "key": "Value",
                            "length": "18"
                        },
                        {
                            "key": "SectionName"
                        },
                        {
                            "key": "Section"
                        }
                    ]
                    print(self.table_formatter(object_instance.configurationAdvanced(), fields))
                else:
                    print("WARNING: no \"%s\" keyword defined for object of type %s" % (predicate, type(object_instance)))
            elif predicate == "transcoders":
                if isinstance(object_instance, WztrVhost):
                    # transcoder templates for vhost
                    self.__ls_objects(object_instance.transcodertemplates().values())
                elif isinstance(object_instance, WztrTranscodertemplate):
                    # transcoder template specified withoutany further predicate
                    print("/configuration\n\n")
                else:
                    print("WARNING: no \"%s\" keyword defined for object of type %s" % (predicate, type(object_instance)))
            elif predicate == "apps":
                if isinstance(object_instance, WztrApplication):
                    # application specified, return detailed view
                    print("%s: %s" % (object_instance.header_singular, object_instance))
                    print( self.dict_formatter( object_instance.detail_view() ) )
                    
                elif isinstance(object_instance, WztrVhost):
                    # vhost specified, list applications
                    self.__ls_objects(object_instance.applications().values())
            elif predicate == "mediacache":
                if isinstance(object_instance, WztrVhost):
                    # vhost specified, list mediacache content
                    self.__ls_objects(object_instance.mediacachecontent().values())
                else:
                    print("WARNING: no \"%s\" keyword defined for object of type %s" % (predicate, type(object_instance)))
            elif predicate == "incomingstreams":
                if isinstance(object_instance, WztrMachine):
                    # machine specified, list incoming streams
                    item_list += object_instance.incomingstreams()
                    
                    self.__ls_objects(item_list)
                else:
                    print("WARNING: no \"%s\" keyword defined for object of type %s" % (predicate, type(object_instance)))
                
            
    def complete_ls(self, text, line, begidx, endidx):
        path_to_match=text.split(" ")[-1]
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, path_to_match)
        items = [i for i in result["completion"] if i.startswith(path_to_match)]
        
        return self.delimiter_complete(path_to_match, line, begidx, endidx, items, "/")


    def do_mediacache(self, inp):
        print()
        
        inputline = inp.split(" ",1)
        arg1=None
        arg2=None
        if len(inputline) > 0:
            arg1=inputline[0]
            if len(inputline) > 1:
                arg2=inputline[1]
        
        if arg1 == "flush":
            if arg2 and arg2 != "":
                self.__get_obj_by_path(WztrPrompt.syntaxtree_mediacache_flush, arg2)

                if self.command_error is None:
                    if self.command_object is None or not isinstance(self.command_object, WztrMediacacheItem):
                        print("** Error: invalid mediacache item specified")
                    else:
                        # rimuovi dalla mediacache del server wowza
                        self.command_object.flush()
                else:
                    print("** Error: %s" % self.command_error)
            else:
                print("** Error: no mediacache item specified")
        elif arg1 == "ls":
            if arg2 and arg2 != "":
                self.__get_obj_by_path(WztrPrompt.syntaxtree_mediacache_ls, arg2)
                if self.command_error is None:
                    if self.command_object is None:
                        if self.command_objects is None:
                            self.__ls_objects(self.machines.values(), "mediacache")
                        else:
                            self.__ls_objects(self.command_objects, "mediacache")
                    else:
                        if not isinstance(self.command_object, WztrVhost):
                            print("** Error: invalid VHost specified")
                        else:
                            self.__ls_object(self.command_object, "mediacache")
                else:
                    print("** Error: %s" % self.command_error)
            else:
                self.__ls_objects(self.machines.values(), "mediacache")
            
        elif arg1 == None or arg1 == '':
            print("** Error: missing arguments")
        else:
            print("** Error: %s unrecognized" % arg1)

    def complete_mediacache(self, text, line, begidx, endidx):
        line_args = line.split(" ")
        line_args_count = len(line_args)
        path_to_match=text.split(" ")[-1]
        
        subcom = ""
        try:
            subcomm = line_args[1]
        except:
            pass
            
        items=[]
        if line_args_count == 3:
            result={"completion": []}
            if subcomm == "ls":
                result = self.__get_obj_by_path(WztrPrompt.syntaxtree_mediacache_ls, path_to_match)
            if subcomm == "flush":
                result = self.__get_obj_by_path(WztrPrompt.syntaxtree_mediacache_flush, path_to_match)
                
            items = [i for i in result["completion"] if i.startswith(path_to_match)]
        if line_args_count < 3:
            items=["ls", "flush"]
        
        return self.delimiter_complete(path_to_match, line, begidx, endidx, items, "/")

    def help_mediacache(self):
        print("List and flush items in Wowza Mediacache")
        print()


    def do_status(self, inp):
        print()
        
        inputline = inp.split(" ",1)
        arg1=None
        arg2=None
        if len(inputline) > 0:
            arg1=inputline[0]
            if len(inputline) > 1:
                arg2=inputline[1]
        
        if arg1 == "incomingstreams":
            if arg2 and arg2 != "":
                self.__get_obj_by_path(WztrPrompt.syntaxtree_status_incomingstreams, arg2)
                if self.command_error is None:
                    if self.command_object is not None and isinstance(self.command_object, WztrMachine):
                        self.__ls_object(self.command_object, "incomingstreams")
                    else:
                        print("** Error: invalid server specified")
                else:
                    print("** Error: %s" % self.command_error)
            else:
                print("** Error: no server specified")
            
        elif arg1 == None or arg1 == '':
            print("** Error: missing arguments")
        else:
            print("** Error: %s unrecognized" % arg1)

    def complete_status(self, text, line, begidx, endidx):
        line_args = line.split(" ")
        line_args_count = len(line_args)
        path_to_match=text.split(" ")[-1]
        
        subcom = ""
        try:
            subcomm = line_args[1]
        except:
            pass
            
        items=[]
        if line_args_count == 3:
            result={"completion": []}
            if subcomm == "incomingstreams":
                result = self.__get_obj_by_path(WztrPrompt.syntaxtree_status_incomingstreams, path_to_match)
                
            items = [i for i in result["completion"] if i.startswith(path_to_match)]
        if line_args_count < 3:
            items=["incomingstreams"]
        
        return self.delimiter_complete(path_to_match, line, begidx, endidx, items, "/")

    def help_status(self):
        print("Shows status information")
        print()




    def do_rm(self, inp):
        print()
        
        self.__get_obj_by_path(WztrPrompt.syntaxtree_remove, inp)
        
        if self.command_error is None:
            if isinstance(self.command_object, WztrApplication):
                self.command_object.remove()
            else:
                print("** Error: invalid application specified")
        else:
            print("** Error: %s" % self.command_error)

    def complete_rm(self, text, line, begidx, endidx):
        path_to_match=text.split(" ")[-1]
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_remove, path_to_match)
        items = [i for i in result["completion"] if i.startswith(path_to_match)]
        
        return self.delimiter_complete(path_to_match, line, begidx, endidx, items, "/")


    def do_playlist(self, inp):
        print()
        
        inputline = inp.split(" ",1)
        arg1=None
        arg2=None
        if len(inputline) > 0:
            arg1=inputline[0]
            if len(inputline) > 1:
                arg2=inputline[1]
        
        if arg1 == "reload" or arg1 == "unload":
            if arg2 and arg2 != "":
                self.__get_obj_by_path(WztrPrompt.syntaxtree_playlist, arg2)

                if self.command_error is None:
                    if self.command_object is None or not isinstance(self.command_object, WztrApplication):
                        print("** Error: invalid application specified")
                    else:
                        if arg1 == "reload":
                            # reload playlist
                            self.command_object.playlist_reload()
                        elif arg1 == "unload":
                            # unload playlist
                            self.command_object.playlist_unload()
            else:
                print("** Error: no mediacache item specified")
            
        elif arg1 == None or arg1 == '':
            print("** Error: missing arguments")
        else:
            print("** Error: %s unrecognized" % arg1)


    def complete_playlist(self, text, line, begidx, endidx):
        line_args = line.split(" ")
        line_args_count = len(line_args)
        path_to_match=text.split(" ")[-1]
        
        subcom = ""
        try:
            subcomm = line_args[1]
        except:
            pass
            
        items=[]
        if line_args_count == 3:
            result={"completion": []}
            if subcomm == "reload" or subcomm == "unload":
                result = self.__get_obj_by_path(WztrPrompt.syntaxtree_playlist, path_to_match)
                
            items = [i for i in result["completion"] if i.startswith(path_to_match)]
        if line_args_count < 3:
            items=["reload", "unload"]
        
        return self.delimiter_complete(path_to_match, line, begidx, endidx, items, "/")




    def do_diff(self, inp):
        input_arr = inp.split(" ")
        if len(input_arr) == 2:
            result_arg_2 = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff, input_arr[1])
            result_arg_1 = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff, input_arr[0])
        
            if result_arg_1["error"] is None:
                if result_arg_1["object"] is not None:
                    source_machine = None
                    source_vhost = None
                    source_app = None
                    source_transtempl = None
                    source_smil = None
                    if isinstance(result_arg_1["object"], WztrApplication):
                        source_app = result_arg_1["object"]
                        source_vhost = source_app.vhost
                        source_machine = source_vhost.machine
                    elif isinstance(result_arg_1["object"], WztrVhost):
                        source_vhost = result_arg_1["object"]
                        source_machine = source_vhost.machine
                    elif isinstance(result_arg_1["object"], WztrTranscodertemplate):
                        source_transtempl = result_arg_1["object"]
                        source_vhost = source_transtempl.vhost
                        source_machine = source_vhost.machine
                    elif isinstance(result_arg_1["object"], WztrSmilFile):
                        source_smil = result_arg_1["object"]
                        source_app = source_smil.application
                        source_vhost = source_app.vhost
                        source_machine = source_vhost.machine
                    else:
                        print("** Error: %s is not an application, transcoder template, SMIL file or vhost object" % result_arg_1["object"])
                    
                    if source_machine is not None:
                        if result_arg_2["error"] is None:
                            if result_arg_2["object"] is not None:
                                # all objects have been provided, check the target instance
                                target_machine = None
                                target_vhost = None
                                target_app = None
                                target_transtempl = None
                                target_smil = None
                                if isinstance(result_arg_2["object"], WztrMachine):
                                    target_machine = result_arg_2["object"]
                                elif isinstance(result_arg_2["object"], WztrVhost):
                                    target_vhost = result_arg_2["object"]
                                    target_machine = target_vhost.machine
                                elif isinstance(result_arg_2["object"], WztrApplication):
                                    target_app = result_arg_2["object"]
                                    target_vhost = target_app.vhost
                                    target_machine = target_vhost.machine
                                elif isinstance(result_arg_2["object"], WztrTranscodertemplate):
                                    target_transtempl = result_arg_2["object"]
                                    target_vhost = target_transtemp.vhost
                                    target_machine = target_vhost.machine
                                elif isinstance(result_arg_2["object"], WztrSmilFile):
                                    target_smil = result_arg_2["object"]
                                    target_app = target_smil.application
                                    target_vhost = target_app.vhost
                                    target_machine = target_vhost.machine
                                
                                else:
                                    print("** Error: %s is not a machine, vhost, transcoder template, SMIL file or application" % result_arg_2["object"])
                                if target_machine is not None:
                                    # create path for target obj
                                    if target_app is None:
                                        target_app = source_app
                                    if target_vhost is None:
                                        target_vhost = source_vhost
                                    if target_transtempl is None:
                                        target_transtempl = source_transtempl
                                    if target_smil is None:
                                        target_smil = source_smil
                                        
                                    target_path = ""
                                    source_path = ""
                                    source_obj = None
                                    if source_app is not None:
                                        if source_smil is not None:
                                            target_path = "%s/%s/apps/%s/smil/%s" % (target_machine.name, target_vhost.name, target_app.name, target_smil.name)
                                            source_path = "%s/%s/apps/%s/smil/%s" % (source_machine.name, source_vhost.name, source_app.name, source_smil.name)
                                            source_obj = source_smil
                                        else:
                                            target_path = "%s/%s/apps/%s" % (target_machine.name, target_vhost.name, target_app.name)
                                            source_path = "%s/%s/apps/%s" % (source_machine.name, source_vhost.name, source_app.name)
                                            source_obj = source_app
                                        
                                        
                                    elif source_transtempl is not None:
                                        target_path = "%s/%s/transcoders/%s" % (target_machine.name, target_vhost.name, target_transtempl.name)
                                        source_path = "%s/%s/transcoders/%s" % (source_machine.name, source_vhost.name, target_transtempl.name)
                                        source_obj = source_transtempl
                                        
                                    elif source_vhost is not None:
                                        target_path = "%s/%s/apps" % (target_machine.name, target_vhost.name)
                                        source_path = "%s/%s/apps" % (source_machine.name, source_vhost.name)
                                        source_obj = source_vhost
                                        
                                    if target_path != source_path:
                                        # check target obj exists
                                        target_path_result = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff, target_path)
                                        target_obj = target_path_result["object"]
                                        
                                        if target_path_result["error"] is None and target_obj is not None:
                                            
                                            
                                            
                                            
                                            
                                            # perform difference and put result in the "diffs" list
                                            diffs = None
                                            if isinstance(target_obj, WztrApplication):
                                                if result_arg_1["predicate"] is not None:
                                                    if result_arg_1["predicate"] == "smil":
                                                        diffs = self.__diff_smilfile_list(source_obj.smilfiles(), target_obj.smilfiles())
                                                        
                                                    else:
                                                        # application objects with no (recognized) predicate
                                                        diffs = WztrPrompt.__diff_application_configs(source_obj, target_obj)
                                                    
                                            elif isinstance(target_obj, WztrTranscodertemplate):
                                                # for a transcoder template obj with a "configuration" predicate,
                                                # perform a difference on the template config
                                                diff_result = WztrPrompt.config_diff(source_obj.configuration(), target_obj.configuration())
                                                diffs = diff_result["diffs"]
                                            elif isinstance(target_obj, WztrVhost):
                                                if result_arg_1["predicate"] is not None:

                                                    if result_arg_1["predicate"] == "configuration":
                                                        # for vhost obj with a "configuration" predicate,
                                                        # perform a difference on the vhost config
                                                        diffs = WztrPrompt.__diff_application_configs(source_obj, target_obj)

                                                    elif result_arg_1["predicate"] == "transcoders":
                                                        # for vhost obj with a "transcoders" predicate,
                                                        # perform a difference on the list of transcoder templates
                                                        diffs = self.__diff_transcoder_list(source_obj.transcodertemplates(), target_obj.transcodertemplates())

                                                    elif result_arg_1["predicate"] == "apps":
                                                        # perform a difference on the list of applications
                                                        diffs = self.__diff_application_list(source_obj.applications(), target_obj.applications())
                                                    elif result_arg_1["predicate"] == "smil":
                                                        # perform a difference on the aggregated list of SMIL files
                                                        diffs = self.__diff_smilfile_list(source_obj.smilfiles(), target_obj.smilfiles())

                                                else:
                                                    # for vhost obj without predicate
                                                    diffs = []

                                                    nodiff = self.__diff_application_list_aggregate(source_obj.applications(), target_obj.applications())
                                                    if nodiff:
                                                        diff_state = "no diff"
                                                    else:
                                                        diff_state = "*** mismatch"
                                                    diffs.append( {
                                                        "key": "apps",
                                                        "value_1": diff_state,
                                                        "value_2": diff_state
                                                    })
                                                    
                                                    nodiff = self.__diff_transcoder_list_aggregate(source_obj.transcodertemplates(), target_obj.transcodertemplates())
                                                    if nodiff:
                                                        diff_state = "no diff"
                                                    else:
                                                        diff_state = "*** mismatch"
                                                    diffs.append( {
                                                        "key": "transcoders",
                                                        "value_1": diff_state,
                                                        "value_2": diff_state
                                                    })
                                                    
                                                    nodiff = self.__diff_smilfile_list_aggregate(source_obj.smilfiles(), target_obj.smilfiles())
                                                    if nodiff:
                                                        diff_state = "no diff"
                                                    else:
                                                        diff_state = "*** mismatch"
                                                    diffs.append( {
                                                        "key": "SMIL files",
                                                        "value_1": diff_state,
                                                        "value_2": diff_state
                                                    })
                                            
                                            elif isinstance(target_obj, WztrSmilFile):
                                                # for a SMIL file obj with no predicate,
                                                # perform a difference on the SMIL config
                                                diff_result = WztrPrompt.config_diff(source_obj.configuration(), target_obj.configuration())
                                                diffs = diff_result["diffs"]
                                            else:
                                                print("** Error: object %s on machine %s is not an application" % (result_arg_1["object"].name, target_machine))

                                            print(WztrPrompt.diff_formatter(source_obj, target_obj, diffs))
                                            
                                        else:
                                            print("** Error: cannot find object %s" % (target_path))
                                    else:
                                        print("** Error: source and destination are the same")
                            else:
                                print("** Error: please specify an object to compare")
                        else:
                            print("** Error: %s" % result_arg_2["error"])
                else:
                    print("** Error: please specify a source object to compare")
            else:
                print("** Error: %s" % result_arg_1["error"])
        else:
            print("** Error: usage: diff <application> <machine>")

    @staticmethod
    def __diff_application_configs(app1, app2):
        # for application objects, perform difference on config
        # and advanced config
        diff_result = WztrPrompt.config_diff(app1.configuration(), app2.configuration())
        diffs = diff_result["diffs"]
        
        # converti la lista di Properties in un dict per avere una differenza indipendente dall'ordine
        prop_dict_1={}
        prop_dict_2={}
        for prop_cur in app1.configurationAdvanced():
            key_cur="%s/%s" % (prop_cur["SectionName"], prop_cur["Name"])
            if key_cur in prop_dict_1.keys():
                key_cur = "%s(dupl)" % key_cur
            prop_dict_1[key_cur]=prop_cur
        for prop_cur in app2.configurationAdvanced():
            key_cur="%s/%s" % (prop_cur["SectionName"], prop_cur["Name"])
            if key_cur in prop_dict_2.keys():
                key_cur = "%s(dupl)" % key_cur
            prop_dict_2[key_cur]=prop_cur
        diff_result = WztrPrompt.config_diff(prop_dict_1, prop_dict_2)
        diffs += diff_result["diffs"]
        
        return diffs
    
    @staticmethod
    def __diff_application_list_execute(apps_1, apps_2):
        identical_lists = True
        # perform a difference on the list of applications
        diffs = []

        # comparing dictionaries
        apps_1_found_in_apps_2=[]
        apps_1_keys = apps_1.keys()
        apps_2_keys = apps_2.keys()
        for key_1 in apps_1_keys:
            if key_1 in apps_2_keys:
                apps_1_found_in_apps_2.append(key_1)
                app_diffs = WztrPrompt.__diff_application_configs(apps_1[key_1], apps_2[key_1])
                if len(app_diffs) > 0:
                    diff_state = "*** conf mismatch"
                    identical_lists = False
                else:
                    diff_state = "no diff"
                diffs.append( {
                    "key": key_1,
                    "value_1": diff_state,
                    "value_2": diff_state
                })
            else:
                # la app e' presente in apps_1 ma non in apps_2
                diffs.append( {
                    "key": key_1,
                    "value_1": "app present",
                    "value_2": "*** no app"
                })
                identical_lists = False
        # trova le app che sono presenti in apps_2 ma non in apps_1
        for app2key in apps_2_keys:
            if app2key not in apps_1_keys:
                diffs.append( {
                    "key": app2key,
                    "value_1": "*** no app",
                    "value_2": "app present"
                })
                identical_lists = False
        
        return diffs, identical_lists


    @staticmethod
    def __diff_application_list(apps_1, apps_2):
        diffs, identical_lists = WztrPrompt.__diff_application_list_execute(apps_1, apps_2)
        return diffs

    @staticmethod
    def __diff_application_list_aggregate(apps_1, apps_2):
        diffs, identical_lists = WztrPrompt.__diff_application_list_execute(apps_1, apps_2)
        return identical_lists




    @staticmethod
    def __diff_generic_list_execute(items_1, items_2, obj_type):
        identical_lists = True
        diffs = []
        
        msg_match = "no diff"
        msg_no_match = "*** mismatch"
        msg_missing = "*** missing"
        msg_present = "present"
        msg_error = "*** error"
        
        if obj_type == "smil":
            msg_match = "no diff"
            msg_no_match = "*** SMIL mismatch"
            msg_missing = "*** no SMIL"
            msg_present = "SMIL present"
            msg_error = "*** bad XML"
        elif obj_type == "transcoder":
            msg_match = "no diff"
            msg_no_match = "*** templ mismatch"
            msg_missing = "*** no templ"
            msg_present = "templ present"
            
        
        # comparing dictionaries
        templ_source_found_in_templ_target=[]
        templ_source_keys = items_1.keys()
        templ_target_keys = items_2.keys()
        
            
        for key_source in templ_source_keys:
            if key_source in templ_target_keys:
                templ_source_found_in_templ_target.append(key_source)
                if 'bad-data' not in items_1[key_source].configuration().keys() and 'bad-data' not in items_2[key_source].configuration().keys():
                    # non ci sono problemi nei dati di configurazione
                    templ_diffs = WztrPrompt.config_diff(items_1[key_source].configuration(), items_2[key_source].configuration())

                    diff_state = msg_match
                    if len(templ_diffs["diffs"]) > 0:
                        diff_state = msg_no_match
                        identical_lists = False

                    diffs.append( {
                        "key": key_source,
                        "value_1": diff_state,
                        "value_2": diff_state
                    })
                else:
                    if 'bad-data' in items_1[key_source].configuration().keys():
                        diffs.append( {
                            "key": key_source,
                            "value_1": msg_error,
                            "value_2": msg_present
                        })
                    else:
                        diffs.append( {
                            "key": key_source,
                            "value_1": msg_present,
                            "value_2": msg_error
                        })
                    
            else:
                # il template e' presente in source ma non in target
                diff_state = msg_present
                if 'bad-data' in items_1[key_source].configuration().keys():
                    diff_state = msg_error
                diffs.append( {
                    "key": key_source,
                    "value_1": diff_state,
                    "value_2": msg_missing
                })
                identical_lists = False
        # trova i template che sono presenti in target ma non in source
        for key_target in templ_target_keys:
            if key_target not in templ_source_keys:
                diff_state = msg_present
                if 'bad-data' in items_2[key_target].configuration().keys():
                    diff_state = msg_error
                
                diffs.append( {
                    "key": key_target,
                    "value_1": msg_missing,
                    "value_2": diff_state
                })
                identical_lists = False
        return diffs, identical_lists

    @staticmethod
    def __diff_transcoder_list(apps_1, apps_2):
        diffs, identical_lists = WztrPrompt.__diff_generic_list_execute(apps_1, apps_2, "transcoder")
        return diffs

    @staticmethod
    def __diff_transcoder_list_aggregate(apps_1, apps_2):
        diffs, identical_lists = WztrPrompt.__diff_generic_list_execute(apps_1, apps_2, "transcoder")
        return identical_lists


    @staticmethod
    def __diff_smilfile_list(apps_1, apps_2):
        diffs, identical_lists = WztrPrompt.__diff_generic_list_execute(apps_1, apps_2, "smil")
        return diffs

    @staticmethod
    def __diff_smilfile_list_aggregate(apps_1, apps_2):
        diffs, identical_lists = WztrPrompt.__diff_generic_list_execute(apps_1, apps_2, "smil")
        return identical_lists
        
        
    def complete_diff(self, text, line, begidx, endidx):
        path_to_match=text.split(" ")[-1]
        
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff, path_to_match)
        items = [i for i in result["completion"] if i.startswith(text)]

        return self.delimiter_complete(path_to_match, line, begidx, endidx, items, "/")


    def help_diff(self):
        print("Compare VHosts, Applications, Transcoder templates and SMIL files on Wowza Servers")
        print()



    def help_ls(self):
        print("List items and configurations")
        print("Application list reports four flags (\"X\" means enabled, \"-\" disabled):")
        print("    - (DVR) -> DVR feature to pause a live stream")
        print("    - (DRM) -> DRM protection")
        print("    - (TRC) -> Transcoders")
        print("    - (STG) -> Stream Targets")
        print()

    def help_rm(self):
        print("Remove application on Wowza server")
        print()

    def do_refresh(self, inp):
        for machinename in self.machines.keys():
            self.machines[machinename].reset_cache()
                     
    def help_refresh(self):
        print("refresh info from servers")
        print()

    def help_playlist(self):
        print("manage playlists from StreamPublisher")
        print()


    @staticmethod
    def config_diff(config_obj_1, config_obj_2):
        error=None
        diffs=[]
        if type(config_obj_1) == type(config_obj_2):
            if isinstance(config_obj_1, dict):
                # comparing dictionaries
                keys_obj1_found_in_obj2=[]
                obj_1_keys = config_obj_1.keys()
                obj_2_keys = config_obj_2.keys()
                for key_1 in obj_1_keys:
                    if key_1 in obj_2_keys:
                        keys_obj1_found_in_obj2.append(key_1)
                        next_obj_1=config_obj_1[key_1]
                        next_obj_2=config_obj_2[key_1]
                        if key_1 == "Modules":
                            # nel confrontare i moduli
                            # converti la lista di moduli in un dict di moduli con il nome come chiave
                            next_obj_1={}
                            next_obj_2={}
                            if type(config_obj_1[key_1]["Module"]) is not list:
                                config_obj_1[key_1]["Module"] = [ config_obj_1[key_1]["Module"] ]
                            for module_cur in config_obj_1[key_1]["Module"]:
                                if module_cur["Name"] not in next_obj_1.keys():
                                    next_obj_1[module_cur["Name"]]=module_cur
                                else:
                                    next_obj_1["%s-%s" % (module_cur["Name"], module_cur["Order"])]=module_cur
                            if type(config_obj_2[key_1]["Module"]) is not list:
                                config_obj_2[key_1]["Module"] = [ config_obj_2[key_1]["Module"] ]
                            for module_cur in config_obj_2[key_1]["Module"]:
                                if module_cur["Name"] not in next_obj_2.keys():
                                    next_obj_2[module_cur["Name"]]=module_cur
                                else:
                                    next_obj_2["%s-%s" % (module_cur["Name"], module_cur["Order"])]=module_cur
                        if key_1 == "TranscoderConfig":
                            # nel confrontare la configurazione dei moduli
                            # rimuovi l'attributo LicensesInUse che non e'
                            # significativo nel confrontare le configurazioni
                            if "LicensesInUse" in config_obj_1[key_1].keys():
                                del config_obj_1[key_1]["LicensesInUse"]
                            if "LicensesInUse" in config_obj_2[key_1].keys():
                                del config_obj_2[key_1]["LicensesInUse"]
                            
                        #result = WztrPrompt.config_diff(config_obj_1[key_1], config_obj_2[key_1])
                        result = WztrPrompt.config_diff(next_obj_1, next_obj_2)
                        
                        for diff in result["diffs"]:
                            diff["key"] = "%s/%s" % (key_1, diff["key"])
                            diffs.append(diff)
                    else:
                        # la key e' presente in obj_1 ma non in obj_2
                        diffs.append( {
                            "key": key_1,
                            "value_1": config_obj_1[key_1],
                            "value_2": None
                        })
                # trova le key che sono presenti in obj_2 ma non in obj_1
                for obj2key in obj_2_keys:
                    if obj2key not in obj_1_keys:
                        diffs.append( {
                            "key": obj2key,
                            "value_1": None,
                            "value_2": config_obj_2[obj2key]
                        })
                        
                        
                        
            elif isinstance(config_obj_1, list):
                # comparing lists
                index = 0
                for item1 in config_obj_1:
                    if index < len(config_obj_2):
                        item2 = config_obj_2[index]
                        result = WztrPrompt.config_diff(item1, item2)
                        for diff in result["diffs"]:
                            diff["key"] = "%s/%s" % (str(index), diff["key"])
                            diffs.append(diff)
                    else:
                        # la lista config_obj_1 contiene piu' elementi di config_obj_2
                        diffs.append( {
                            "key": str(index),
                            "value_1": item1,
                            "value_2": None
                        })
                    index += 1
                    
                # cntrolla se la lista config_obj_2 contiene piu' elementi di config_obj_1
                while index < len(config_obj_2):
                    item2 = config_obj_2[index]
                    diffs.append( {
                        "key": str(index),
                        "value_1": None,
                        "value_2": item2
                    })
                    index += 1
            else:
                # assuming objects that are not lists of dicts can be compared directly
                if config_obj_1 != config_obj_2:
                    diffs.append( {
                        "key": "",
                        "value_1": config_obj_1,
                        "value_2": config_obj_2
                    })
            
        else:
            #error = "cannot compare %s with %s" % (type(config_obj_1), type(config_obj_2))
            diffs.append( {
                "key": "",
                "value_1": "type=%s" % type(config_obj_1),
                "value_2": "type=%s" % type(config_obj_2)
            })
            
        
        return {
            "diffs": diffs,
            "error": error
        }
        
    @staticmethod
    def dict_formatter(data_dict, level=0, table_attrs=None):
        output=""
        margin = " " * (level*2)
        for cur_key in data_dict.keys():
            if isinstance(data_dict[cur_key], dict):
                output += "%s  %-16s:\n" % (margin, cur_key)
                output += WztrPrompt.dict_formatter(data_dict[cur_key], level+1, table_attrs)
            elif type(data_dict[cur_key]) is list:
                
                # controlla se questo elemento deve essere renderizzato come tabella
                if table_attrs is not None and cur_key in table_attrs.keys():
                    output += WztrPrompt.table_formatter(data_dict[cur_key], table_attrs[cur_key])
                else:
                    if len(data_dict[cur_key]) == 0:
                        output += "%s  %-16s: []\n" % (margin, cur_key)
                    else:
                        if type(data_dict[cur_key][0]) is dict:
                            output += "%s  %-16s:\n" % (margin, cur_key)
                            output += WztrPrompt.list_formatter(data_dict[cur_key], level+1, table_attrs)
                        else:
                            output += "%s  %-16s: [%s]\n" % (margin, cur_key, ", ".join(data_dict[cur_key]))
            else:
                output += "%s  %-16s: %s\n" % (margin, cur_key, data_dict[cur_key])
        
        return output

    @staticmethod
    def list_formatter(data_list, level=0, table_attrs=None):
        output=""
        margin = " " * (level*2)
        
        output += margin + "[\n"
        for cur_item in data_list:
            output += margin + "  {\n"
            output += WztrPrompt.dict_formatter(cur_item, level+1, table_attrs)
            output += margin + "  }\n"
        output += margin + "]\n"
        
        return output

    @staticmethod
    def diff_formatter(obj_1, obj_2, diff_list):
        output="\n"
        if diff_list is not None:
            if len(diff_list) == 0:
                output += "  No differences found between %s and %s" % (obj_1, obj_2)
            else:
                output += "%-40s %-40s %-40s\n" % ("Key", obj_1, obj_2)
                output += "-" * 120
                output += "\n"
                for cur_item in diff_list:
                    val1 = cur_item["value_1"]
                    val2 = cur_item["value_2"]
                    if isinstance(val1, list):
                        val1 = "<List>"
                    if isinstance(val1, dict):
                        val1 = "<Dict>"
                    if isinstance(val2, list):
                        val2 = "<List>"
                    if isinstance(val2, dict):
                        val2 = "<Dict>"
                    output += "%-40s %-40s %-40s\n" % (cur_item["key"], val1, val2)
        
            output += "\n"
        return output


    @staticmethod
    def table_formatter(data_list, field_list):
        # field_list contiene un oggetto strutturato come da esempio:
        # key: <field name in the list>
        # title: <name of field in the table header> (optional)
        # length: <number of characters in the field> (optional)
        output=""
        format_string=""
        row=[]
        headerlength=0
        for title_item in field_list:
            if "title" in title_item.keys():
                row.append(title_item["title"])
            else:
                row.append(title_item["key"])
            
            if "length" in title_item.keys():
                format_string += "%-" + title_item["length"] + "s "
                headerlength += int(title_item["length"])
            else:
                format_string += "%s "
                headerlength += 14
                
        format_string += "\n"
        

        output = format_string % tuple(row)
        output += "-" * headerlength + "\n"
        
            
        for cur_item in data_list:
            row = []
            for title_item in field_list:
                if title_item["key"] in cur_item.keys():
                    row.append(cur_item[title_item["key"]])
                else:
                    row.append("-")
            
            output += format_string % tuple(row)
        
        output += "-" * headerlength + "\n"
        
        return output




p=WztrPrompt()
p.cmdloop()





