#!/usr/bin/python3

import httpx
import xmltodict
import json



class WztrApplication():
    header_singular="Application"
    header_plural="Applications"

    def __init__(self, name, href, appType, dvrEnabled=False, drmEnabled=False, transcoderEnabled=False, streamtargetsEnabled=False):
        self.name = name
        self.href = href
        self.appType = appType

        if dvrEnabled == "true":
            self.dvrEnabled = True
        else:
            self.dvrEnabled = False
        if drmEnabled == "true":
            self.drmEnabled = True
        else:
            self.drmEnabled = False
        if transcoderEnabled == "true":
            self.transcoderEnabled = True
        else:
            self.transcoderEnabled = False
        if streamtargetsEnabled == "true":
            self.streamtargetsEnabled = True
        else:
            self.streamtargetsEnabled = False
    
        self.vhost=None
        self.__configuration = None
        self.__configurationAdv = None # this is how app Properties are called in wowza APIs
        
    def __str__(self):
        return "/%s/%s/%s" % (self.vhost.machine.name, self.vhost.name, self.name)
    def __repr__(self):
        return "WztrApplication: %s" % self.name

    @staticmethod
    def list_view_header():
        return "%-8s %-28s %1s%1s%1s%1s" % ("App Type", "Stream Type", "(DVR)", "(DRM)", "(TRC)", "(STG)")
    def list_view(self):
        stream_type="n/a"
        config_dict = self.configuration()
        if config_dict is not None and 'StreamConfig' in config_dict.keys() and 'StreamType' in config_dict['StreamConfig'].keys():
            stream_type = config_dict['StreamConfig']['StreamType']
        
        return "%-8s %-28s %1s%1s%1s%1s  /%s/%s/%s" % (self.appType, stream_type,
            "X" if self.dvrEnabled else "-", "X" if self.drmEnabled else "-",
            "X" if self.transcoderEnabled else "-", "X" if self.streamtargetsEnabled else "-",
            self.vhost.machine.name, self.vhost.name, self.name)
    def detail_view(self):
        stream_type="n/a"
        config_dict = self.configuration()
        if config_dict is not None and 'StreamConfig' in config_dict.keys() and 'StreamType' in config_dict['StreamConfig'].keys():
            stream_type = config_dict['StreamConfig']['StreamType']
        return {
            "App/Stream type": self.appType + " / " + stream_type,
            "Server": "/%s/%s/%s" % (self.vhost.machine.name, self.vhost.name, self.name),
            "DVR": "** ON" if self.dvrEnabled else "OFF",
            "DRM": "** ON" if self.drmEnabled else "OFF",
            "Transcoder": "** ON" if self.transcoderEnabled else "OFF",
            "Targets": "** ON" if self.streamtargetsEnabled else "OFF"
        }


    def configuration(self):
        # lazy-fetch application config
        if self.__configuration is None:
            self.__configuration={}

            result = self.vhost.machine.fetchJson(self.href)

            if 'Application' in result.keys():
                entry = result['Application']
                
                if 'Version' in entry.keys():
                    del entry['Version']
                
                
                if not self.dvrEnabled and 'DVRConfig' in entry.keys():
                    del entry['DVRConfig']
                if not self.drmEnabled and 'DRMConfig' in entry.keys():
                    del entry['DRMConfig']
                if not self.transcoderEnabled and 'TranscoderConfig' in entry.keys():
                    del entry['TranscoderConfig']
                
                self.__configuration = WztrApplication.__clean_config_dict(entry)

        return self.__configuration
    
    @staticmethod
    # recursively remove irrelevant items from configuration dictionary
    def __clean_config_dict(config_dict):
        if '@serverName' in config_dict.keys():
            del config_dict['@serverName']
        
        for key in config_dict.keys():
            if isinstance(config_dict[key], dict):
                cleanitem = WztrApplication.__clean_config_dict(config_dict[key])
                config_dict[key] = cleanitem
        return config_dict
        
    # in wowza APIs, application Properties are referred to as application/advanced
    def configurationAdvanced(self):
        # lazy-fetch application advanced config
        if self.__configurationAdv is None:
            self.__configurationAdv={}
            
            result = self.vhost.machine.fetchJson(self.href + "/adv")
            if 'ApplicationAdv' in result.keys():
                if 'AdvancedSettings' in result['ApplicationAdv'].keys():
                    advSettings = result['ApplicationAdv']['AdvancedSettings']
                    if 'AdvancedSetting' in advSettings.keys():
                        # show only active properties
                        properties=[]
                        for prop in advSettings['AdvancedSetting']:
                            if prop['@enabled'] == 'true':
                                shortprop = {
                                    'Name': prop['Name'],
                                    'Type': prop['Type'],
                                    'Value': prop['Value'],
                                    'SectionName': "",
                                    'Section': ""
                                    
                                }
                                if 'Section' in prop.keys():
                                    shortprop['Section'] = prop['Section']
                                if 'SectionName' in prop.keys():
                                    shortprop['SectionName'] = prop['SectionName']
                            
                                properties.append(shortprop)
                            
                        self.__configurationAdv=properties

        return self.__configurationAdv
        
        
class WztrVhost():
    header_singular="VHost"
    header_plural="VHosts"

    def __init__(self, name, href, connectingIPAddress, connectingPort, connectingSSLEnable=False):
        self.name = name
        self.href = href
        self.connectingPort = connectingPort
        self.connectingIPAddress = connectingIPAddress
        if connectingSSLEnable == "true":
            self.connectingSSLEnable = True
        else:
            self.connectingSSLEnable = False
    
        self.__applications = None
        self.machine=None
    
    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrVhost: %s" % self.name

    @staticmethod
    def list_view_header():
        return "VHost name"
    def list_view(self):
        return str(self)
    def detail_view(self):
        return {
            "Machine": str(self.machine),
            "Addr/Port": "%s/%s" % (self.connectingIPAddress, self.connectingPort),
            "SSL": "YES" if self.connectingSSLEnable else "NO",
        }
    
    
    def applications(self):
        # lazy-fetch applications
        if self.__applications is None:
            self.__applications={}
            result = self.machine.fetchJson("/v2/servers/_defaultServer_/vhosts/%s/applications" % self.name)


            if 'Applications' in result.keys():
                entry = result['Applications']
                if 'Application' in entry.keys():
                    items = entry['Application']
                    for item in items:
                        newapp = WztrApplication(item['@id'], item['@href'], item['AppType'], item['DVREnabled'], item['DRMEnabled'], item['TranscoderEnabled'], item['StreamTargetsEnabled'])
                        newapp.vhost = self
                    
                        self.__applications[newapp.name] = newapp

        return self.__applications

# class used to create a temporary list of licenses and associated servers
# using a class in order to avail of the code to render lists
class WztrLicense():
    header_singular="License"
    header_plural="Licenses"
    
    def __init__(self, key):
        self.key=key
        self.servers=[]

    def __str__(self):
        return self.key
    def __repr__(self):
        return "WztrLicense: %s" % self.key
    
    @staticmethod
    def list_view_header():
        return " %-36s  servers" % ("License key")
    def list_view(self):
        return " %-36s [%s]" % (self.key, ", ".join(self.servers))
    def detail_view(self):
        return {
            "License key": self.key,
            "Servers": self.serers(),
        }
    
    def add_server(self, machine):
        self.servers.append(machine)


    
class WztrMachine():
    header_singular="Machine"
    header_plural="Machines"
    
    def __init__(self, name, address, user, pw, port=None):
        self.name=name
        self.address=address
        self.user=user
        self.pw=pw
        self.use_https=False
        self.__vhosts = None
        self.__version = None
        self.__licenses = None
        
        if port is not None:
            self.port=port
        else:
            self.port="8087"

    def __str__(self):
        return self.name
    def __repr__(self):
        return "WztrMachine: %s" % self.name

    @staticmethod
    def list_view_header():
        return " %-8s %-17s  %s" % ("Name", "address", "Wowza version")
    def list_view(self):
        return " %-8s %-17s [%s]" % (self.name, "(" + self.address + ")", self.version())
    def detail_view(self):
        return {
            "Address": self.address,
            "Version": self.version(),
            "HTTPS": "YES" if self.use_https else "NO",
            "Credentials": {
                "user": self.user,
                "pw": "*******"
            },
            "Licenses": self.licenses()
        }
        
    def fetch(self, url):
        try:
            base_url="http://"
            if self.use_https:
                base_url="https://"
            
            base_url += self.address
            url = "%s:%s%s" % (base_url, self.port, url) 
            
            response = httpx.get(
                url,
                auth=httpx.DigestAuth(
                    self.user, self.pw
                ),
                timeout=httpx.Timeout(timeout=5)
            )
            
            return response.text

        except httpx.exceptions.ConnectTimeout:
            print('timeout getting %s on machine %s' % (url, self))
            return False
        except Exception as e:
            print('error getting %s on machine %s' % (url, self))
            print(e)
            return False
        
    def fetchJson(self, url):
        xmlresponse = self.fetch(url)
        
        jsonresponse = xmltodict.parse(
            xmlresponse,
            dict_constructor=dict,
            xml_attribs=True,
            force_list=('VHosts')
        )
        
        return jsonresponse
    
    
    def reset_cache(self):
        self.__vhosts = None
        self.__version = None
    
    def vhosts(self):
        # lazy-fetch vhosts
        if self.__vhosts is None:
            self.__vhosts={}
            vhosts = (self.fetchJson("/v2/servers/_defaultServer_/vhosts"))

            if 'VHosts' in vhosts.keys():
                for vhost_entry in vhosts['VHosts']:
                    vhost = vhost_entry['Vhost']
                    newvh = WztrVhost(vhost['@id'], vhost['@href'], vhost['@connectingIPAddress'], vhost['@connectingPort'], vhost['@connectingSSLEnable'])
                    newvh.machine = self
                    
                    self.__vhosts[newvh.name] = newvh

        return self.__vhosts

    def version(self):
        # lazy-fetch version
        if self.__version is None:
            self.__version = "*** No connection ***"
            try:
                self.__version = (self.fetch(""))
            
            except:
                pass
        
        return self.__version



    def licenses(self):
        # lazy-fetch machine config
        if self.__licenses is None:
            self.__licenses={}

            result = self.fetchJson("/v2/servers/_defaultServer_/licenses")
            
            self.__licenses = {}
            if 'ServerLicenses' in result.keys():
                entry = result['ServerLicenses']
                
                if 'Licenses' in entry.keys():
                    entry = entry['Licenses']
                    if 'string' in entry.keys():
                        index=0
                        if isinstance(entry['string'], list):
                            for lic in entry['string']:
                                self.__licenses[index] = lic
                                index += 1
                        else:
                            self.__licenses[index] = entry['string']

        return self.__licenses





from cmd2 import Cmd
import json, sys

_CONFIGFILE="config.json"





class WztrPrompt(Cmd):
    prompt = 'wowzator> '
    intro = "\nWowzator: a simple Wowza Configuration Manager by Top-IX\nType ? to list commands, TAB to autocomplete\n"
    
    
    # Syntax tree for the list commeand
    syntaxtree_ls = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "vhosts",
                    "keyword_type": "predicate",
                    "syntaxtree": [ 
                        { 
                            "keyword": "$VHOST",
                            "keyword_type": "object",
                            "syntaxtree": [
                                {
                                    "keyword": "applications",
                                    "keyword_type": "predicate",
                                    "syntaxtree": [
                                        {
                                            "keyword": "$APPLICATION",
                                            "keyword_type": "object",
                                            "syntaxtree": [
                                                {
                                                    "keyword": "configuration",
                                                    "keyword_type": "predicate",
                                                    "syntaxtree": [
                                                        {
                                                            "keyword": "properties",
                                                            "keyword_type": "predicate",
                                                            "syntaxtree": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "keyword": "transcoders",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                }
                            ]
                        } 
                    ]
                } 
            ]
        },
        {
            "keyword": "$ALL_MACHINES",
            "keyword_type": "multi_object",
            "syntaxtree": [
                {
                    "keyword": "applications",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                },
                {
                    "keyword": "licenses",
                    "keyword_type": "predicate",
                    "syntaxtree": []
                }
            ]
        }
    ]


    # Syntax tree for the diff commeand (first argument)
    syntaxtree_diff_1 = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": [ 
                { 
                    "keyword": "vhosts",
                    "keyword_type": "predicate",
                    "syntaxtree": [ 
                        { 
                            "keyword": "$VHOST",
                            "keyword_type": "object",
                            "syntaxtree": [
                                {
                                    "keyword": "applications",
                                    "keyword_type": "predicate",
                                    "syntaxtree": [
                                        {
                                            "keyword": "$APPLICATION",
                                            "keyword_type": "object",
                                            "syntaxtree": []
                                        }
                                    ]
                                },
                                {
                                    "keyword": "transcoders",
                                    "keyword_type": "predicate",
                                    "syntaxtree": []
                                }
                            ]
                        } 
                    ]
                } 
            ]
        },
    ]
    # Syntax tree for the diff commeand (second argument)
    syntaxtree_diff_2 = [
        {
            "keyword": "$MACHINE",
            "keyword_type": "object",
            "syntaxtree": []
        },
    ]
    
    
    def __init__(self):
        print("initializing...")
        Cmd.__init__(self)
        
        self.machines = {}
        self.relationsLicenseServer = []
        
        try:
            with open(_CONFIGFILE) as json_file:
                machines_config = json.load(json_file)
        
                for machine_config in machines_config:
                    machine=WztrMachine(name=machine_config["name"], address=machine_config["address"], user=machine_config["user"], pw=machine_config["pw"])
                    self.machines[machine.name]=machine
            

        except Exception as e:
            print(e)
            print("Cannot open %s" % _CONFIGFILE)
            sys.exit(-1)
    
    def do_exit(self, inp):
        print('Bye')
        return True
    
    do_EOF=do_exit
    do_q=do_exit

    # return an array of objects or a single instance depending on what the path points to
    def __get_obj_by_path(self, syntax_tree, path):
        self.command_object = None
        self.command_objects = None
        self.command_predicate = None
        self.command_error = None
        
        completion = []
        
        
        path_arr = path.split("/")
        
        removed_trailing_slash = False
        removed_leading_slash = False
        # set to True by default to deal with empty path
        # if path is provided it will be immediately set to False when path is parsed
        keyword_matched = True
        
        # remove last and first elements of path if empty
        if len(path_arr) > 0 and path_arr[-1] == "":
            path_arr.pop()
            removed_trailing_slash = True
        if len(path_arr) > 0 and path_arr[0] == "":
            path_arr.pop(0)
            removed_leading_slash = True
        
        expanded_syntax_tree = self.__expand_keywords(syntax_tree)
        cur_path_pos = 0
        for cur_path_el in path_arr:
            
            keyword_matched = False
            for syntax_el in expanded_syntax_tree:
                if cur_path_el == syntax_el["keyword"]:

                    if syntax_el["keyword_type"] == "object":
                        self.command_object = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "multi_object":
                        self.command_objects = syntax_el["data"]
                    elif syntax_el["keyword_type"] == "predicate":
                        self.command_predicate = syntax_el["keyword"]

                    # move down syntax tree
                    expanded_syntax_tree = self.__expand_keywords(syntax_el["syntaxtree"])
                    keyword_matched = True
            
            if not keyword_matched:
                self.command_error = "%s: keyword not recognized" % cur_path_el
                cur_path = "/".join(path_arr[:cur_path_pos])
                if cur_path != "":
                    cur_path += "/"
                if removed_leading_slash:
                    cur_path = "/" + cur_path
            
                for syntax_el in expanded_syntax_tree:
                    completion.append( cur_path + syntax_el["keyword"] )
                    if len(syntax_el["syntaxtree"]) > 0:
                        completion.append( cur_path + syntax_el["keyword"] +"/" )

                break
            
                
            cur_path_pos += 1
                
        if keyword_matched:
            cur_path = "/".join(path_arr[:cur_path_pos])
            if cur_path != "":
                cur_path += "/"
            if removed_leading_slash:
                cur_path = "/" + cur_path
        
            for syntax_el in expanded_syntax_tree:
                completion.append( cur_path + syntax_el["keyword"] )
                if len(syntax_el["syntaxtree"]) > 0:
                    completion.append( cur_path + syntax_el["keyword"] +"/" )
            
                        
            
        
        
        return {
            "object": self.command_object,
            "objects": self.command_objects,
            "predicate": self.command_predicate,
            "error": self.command_error,
            "completion": completion
        }

    
    # expand macro keywords in first level of syntax tree
    def __expand_keywords(self, syntax_tree):
        expanded_syntax_tree = []
        for syntax_el in syntax_tree:
            kw = syntax_el["keyword"]
            if kw[0] == "$":
                expanded_dict = self.__expand_keyword_macro(kw)
                for expanded_kw in expanded_dict.keys():
                    exp_syntax_el = {
                        "keyword": expanded_kw,
                        "keyword_type": syntax_el["keyword_type"],
                        "syntaxtree": syntax_el["syntaxtree"],
                        "data": expanded_dict[expanded_kw]
                    }
                    expanded_syntax_tree.append(exp_syntax_el)
            else:
                expanded_syntax_tree.append(syntax_el)
        
        return expanded_syntax_tree
    
    
    
    
    # expand individual macro
    def __expand_keyword_macro(self, keyword):
        expanded_dict = {}
        if keyword == "$MACHINE":
            expanded_dict = self.machines
            #for machine_name in self.machines.keys():
            #    expanded_dict[machine_name]=self.machines[machine_name]
        elif keyword == "$ALL_MACHINES":
            expanded_dict["all"]=self.machines.values()
        elif keyword == "$VHOST":
            expanded_dict = self.command_object.vhosts()
        elif keyword == "$APPLICATION":
            expanded_dict = self.command_object.applications()
        
        return expanded_dict


    def do_ls(self, inp):
        print()
        
        self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, inp)
        
        if self.command_error is None:
            if self.command_object is None:
                if self.command_objects is None:
                    self.__ls_objects(self.machines.values(), self.command_predicate)
                else:
                    self.__ls_objects(self.command_objects, self.command_predicate)
            else:
                self.__ls_object(self.command_object, self.command_predicate)
        else:
            print("** Error: %s" % self.command_error)

    def __ls_objects(self, object_list, predicate=None):
        object_list = list(object_list)
        if len(object_list) > 0:
            if predicate is None:
                print("%s" % object_list[0].header_plural)
                print("%s" % object_list[0].list_view_header())
                for cur_obj in object_list:
                    print(" %s" % cur_obj.list_view())
            else:
                if predicate == 'applications':
                    item_list = []
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            for vhost in machine.vhosts().values():
                                item_list += vhost.applications().values()
                    self.__ls_objects(item_list)
                elif predicate == 'licenses':
                    item_dict = {}
                    for machine in object_list:
                        if isinstance(machine, WztrMachine):
                            for licensekey in machine.licenses.values():
                                if licensekey not in item_dict.keys():
                                    item_dict[licensekey] = WztrLicense(licensekey)
                                item_dict[licensekey].add_server(machine)
                    self.__ls_objects(item_dict.values())
                    
        else:
            print("empty list...")
        print()
        
    def __ls_object(self, object_instance, predicate=None):
        if predicate is None:
            print("%s: %s" % (object_instance.header_singular, object_instance))
            print( self.dict_formatter( object_instance.detail_view() ) )
        else:
            if predicate == "vhosts":
                if isinstance(object_instance, WztrVhost):
                    # details of vhost
                    self.__ls_object(object_instance)
                else:
                    self.__ls_objects(object_instance.vhosts().values())
            elif predicate == "applications":
                if isinstance(object_instance, WztrApplication):
                    # details of app
                    self.__ls_object(object_instance)
                else:
                    self.__ls_objects(object_instance.applications().values())
            elif predicate == "configuration":
                if isinstance(object_instance, WztrApplication):
                    # config of app
                    print(self.dict_formatter(object_instance.configuration()))
            elif predicate == "properties":
                if isinstance(object_instance, WztrApplication):
                    # properties (adv config) of app
                    print(self.list_formatter(object_instance.configurationAdvanced()))
    
    def complete_ls(self, text, line, begidx, endidx):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_ls, text)
        items = [i for i in result["completion"] if i.startswith(text)]
        
        index_dict = {
                1: items
                }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)

    def do_diff(self, inp):
        input_arr = inp.split(" ")
        if len(input_arr) == 2:
            result_arg_2 = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_2, input_arr[1])
            result_arg_1 = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_1, input_arr[0])
        
            if result_arg_1["error"] is None:
                if result_arg_1["object"] is not None:
                    if isinstance(result_arg_1["object"], WztrApplication):
                        if result_arg_2["error"] is None:
                            if result_arg_2["object"] is not None:
                                if isinstance(result_arg_2["object"], WztrMachine):
                                    # all objects have been provided!!
                                    
                                    target_machine = result_arg_2["object"]
                                    
                                    # replace machine name in path of source obj
                                    argument_1_arr = input_arr[0].split("/")
                                    machine_index=1
                                    if argument_1_arr[0] != "":
                                        machine_index=0
                                    
                                    if argument_1_arr[machine_index] != target_machine.name:
                                        argument_1_arr[machine_index] = target_machine.name
                                        target_path = "/".join(argument_1_arr)
                                        target_path_result = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_1, target_path)
                                        if target_path_result["error"] is None and target_path_result["object"] is not None:
                                            if isinstance(target_path_result["object"], WztrApplication):
                                                
                                                print("comparing %s with %s" % (result_arg_1["object"], target_path_result["object"]))
                                                
                                            
                                            else:
                                                print("** Error: object %s on machine %s is not an application" % (result_arg_1["object"].name, target_machine))
                                        else:
                                            print("** Error: cannot find application %s on machine %s" % (result_arg_1["object"].name, target_machine))
                                    else:
                                        print("** Error: source and destination are the same")
                                else:
                                    print("** Error: %s is not a machine" % result_arg_2["object"])
                            else:
                                print("** Error: please specify an object to compare")
                        else:
                            print("** Error: %s" % result_arg_2["error"])
                    else:
                        print("** Error: %s is not an application object" % result_arg_1["object"])
                else:
                    print("** Error: please specify a source object to compare")
            else:
                print("** Error: %s" % result_arg_1["error"])
        else:
            print("** Error: usage: diff <application> <machine>")

    def complete_diff(self, text, line, begidx, endidx):
        result = self.__get_obj_by_path(WztrPrompt.syntaxtree_diff_1, text)
        items_arg_1 = [i for i in result["completion"] if i.startswith(text)]
        items_arg_2 = self.machines.keys()
        
        index_dict = {
                1: items_arg_1,
                2: items_arg_2
                }
        return self.index_based_complete(text, line, begidx, endidx, index_dict=index_dict)
            
    def help_ls(self):
        print("List items and configurations")
        print("Application list reports four flags (\"X\" means enabled, \"-\" disabled): DVR DRM Transcoders Targets")
        
    def do_refresh(self, inp):
        for machinename in self.machines.keys():
            self.machines[machinename].reset_cache()
                     
    def help_refresh(self):
        print("refresh info from servers")


    @staticmethod
    def config_diff(config_obj_1, config_obj_2):
        error=None
        diffs=[]
        if type(config_obj_1) == type(config_obj_2):
            if isinstance(config_obj_1, dict):
                # comparing dictionaries
                keys_obj_1_found=[]
                for key_1 in config_obj_1.keys():
                    if key_1 in config_obj_2.keys():
                        keys_obj_1_found.append(key_1)
                        result = WztrPrompt.config_diff(config_obj_1[key_1], config_obj_2[key_1])
                        if result is not None:
                            result["key"] += key_1 + "/"
                        
                        return result
                        
            elif isinstance(config_obj_1, list):
                # comparing lists
                pass
                
            else:
                # assuming objects can be compared directly
                if config_obj_1 != config_obj_2:
                    return {
                        "key": "",
                        "value_1": config_obj_1,
                        "value_2": config_obj_2
                    }
                else:
                    return None
            
        else:
            error = "cannot compare %s with %s" % (type(config_dict_1), type(config_dict_2))
        
        return {
            "diffs": diffs,
            "error": error
        }
        
    @staticmethod
    def dict_formatter(data_dict, level=0):
        output=""
        margin = "                            "[:level*2]
        for cur_key in data_dict.keys():
            if isinstance(data_dict[cur_key], dict):
                output += "%s  %-14s:\n" % (margin, cur_key)
                output += WztrPrompt.dict_formatter(data_dict[cur_key], level+1)
            elif type(data_dict[cur_key]) is list:
                if len(data_dict[cur_key]) == 0:
                    output += "%s  %-14s: []\n" % (margin, cur_key)
                else:
                    if type(data_dict[cur_key][0]) is dict:
                        output += WztrPrompt.list_formatter(data_dict[cur_key], level+1)
                    else:
                        output += "%s  %-14s: [%s]\n" % (margin, cur_key, ", ".join(data_dict[cur_key]))
            else:
                output += "%s  %-14s: %s\n" % (margin, cur_key, data_dict[cur_key])
        
        return output

    @staticmethod
    def list_formatter(data_list, level=0):
        output=""
        margin = "                            "[:level*2]
        
        output += margin + "[\n"
        for cur_item in data_list:
            output += margin + "  {\n"
            output += WztrPrompt.dict_formatter(cur_item, level+1)
            output += margin + "  }\n"
        output += margin + "]\n"
        
        return output


p=WztrPrompt()
p.cmdloop()





